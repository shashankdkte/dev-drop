# 1. Create Request (Tabular) and Single-Step Approval

One document: data load reference → plan → roadmap → DB → backend → frontend. Only what’s needed for **tabular create** and **approve/reject one request at a time**.

---

## Data load (how it works today — reference only)

So the plan is clear, this is how data is loaded in the scripts. The app will write the **same tables and columns**.

**Scripts:** `Script_Populate/0-Global Script.sql` inserts into `PermissionRequests` and `PermissionHeaders`. `Script_Populate/1-CDI Script.sql` (and 1-AMER, 1-GI, etc.) insert into `RLSPermission*Details` by joining on `PermissionRequests.RequestCode` → `PermissionHeaders` → `RLSPermissions`.

**Insert order in 0-Global Script.sql:**

| Step | Table | Key columns (example) |
|------|--------|------------------------|
| 1 | `dbo.PermissionRequests` | RequestCode (e.g. REQCD10001), WorkspaceId, RequestedFor, RequestedBy, **LMApprover** (from refv.Employees parent or RequestedFor), RequestStatus (0–6), RequestReason, CreatedAt, CreatedBy, UpdatedAt, UpdatedBy |
| 2 | `dbo.PermissionHeaders` | PermissionRequestId (= pr.Id), PermissionType (0=OLS, 1=RLS), ApprovalStatus (0–5), Approvers, ApprovedBy, ApprovedAt, ApproveNote, RejectedBy, RejectedAt, RejectNote, … |
| 3 | `dbo.OLSPermissions` / `dbo.RLSPermissions` | PermissionHeaderId, … |
| 4 | (in 1-CDI etc.) `RLSPermissionCDIDetails` | RLSPermissionsId, EntityKey, ClientKey, SLKey, … (joined via pr.RequestCode) |

**One example (CDI):** Request **REQCD10001** → one row in `PermissionRequests` (RequestedFor=Abhinav.Gaurav@…, RequestedBy=nitin.menon@…, LMApprover from Employees or RequestedFor, RequestStatus=3 Approved). One row in `PermissionHeaders` (PermissionType=1 RLS, ApprovalStatus=2 Approved, Approvers=nitin.menon@…). Then 1-CDI inserts RLS detail rows linked to that request by RequestCode.

**What the app will do:** Tabular create = insert **one row** into `PermissionRequests` (and optionally 1–2 rows into `PermissionHeaders` with ApprovalStatus=0). Approve/Reject = **update** the matching row in `PermissionHeaders` (ApprovalStatus, ApprovedBy/RejectedBy, notes) and then **update** `PermissionRequests.RequestStatus`. Same columns, no new tables.

---

## a) Plan end-to-end

1. **Create (tabular):** User picks workspace, fills RequestedFor, RequestedBy, LMApprover, RequestReason; submits. Backend inserts **one row** into `dbo.PermissionRequests` (like the script: RequestCode, WorkspaceId, RequestedFor, RequestedBy, LMApprover, RequestStatus=0, RequestReason, audit). Optionally inserts 1–2 rows into `dbo.PermissionHeaders` (ApprovalStatus=0, Approvers empty or from config). User sees the new request in the list.
2. **Details:** User opens the request (existing modal). Sees request + OLS/RLS headers (from existing GET). If the current user is the **LM** (RequestStatus=0) or is in a header’s **Approvers** and that header is **Pending** (ApprovalStatus=1), show **Approve** and **Reject** for that header.
3. **Approve/Reject:** User clicks, enters note (required for Reject). Backend **updates** that row in `dbo.PermissionHeaders` (ApprovalStatus, ApprovedBy/RejectedBy, note, UpdatedAt/By), then **updates** `dbo.PermissionRequests.RequestStatus` from the headers. Modal and list refresh.

**In scope:** Tabular create API + UI; single-header approve/reject API + buttons in details modal.  
**Out of scope here:** Wizard submit, “pending for me” list, batch approve, history, delegates, existing rights, email deep link.

---

## b) Roadmap (order of work)

| Step | What |
|------|------|
| 1 | DB: add RequestCode, LMApprover to list view (so list can show them). |
| 2 | Backend: entities for base tables (write); create API; approve/reject API. |
| 3 | Frontend: create API + tabular create screen; approve/reject API + buttons in modal. |

DB first (view change). Then backend (write entities + two APIs). Then frontend (new screen + modal actions).

---

## c) DB changes

**Only one change:**

- **View `romv.PermissionRequests`**  
  Today it returns: RequestId, WorkspaceId, RequestedBy, RequestedFor, RequestStatus, OLSStatus, RLSStatus.  
  **Add to the view:** `RequestCode`, `LMApprover` from `dbo.PermissionRequests` (add to SELECT and to GROUP BY if you keep GROUP BY).

No new tables. No changes to `dbo.PermissionRequests`, `dbo.PermissionHeaders`, or `romv.PermissionHeaders`.

---

## d) Backend changes

**1. Writable entities (so we can insert/update, not only read views)**

- New entity **PermissionRequestRow** → table `dbo.PermissionRequests`: Id, RequestCode, RequestedFor, RequestedBy, LMApprover, RequestStatus, RequestReason, WorkspaceId, CreatedAt, CreatedBy, UpdatedAt, UpdatedBy.
- New entity **PermissionHeaderRow** → table `dbo.PermissionHeaders`: Id, PermissionRequestId, PermissionType, ApprovalStatus, Approvers, ApprovedBy, ApprovedAt, ApproveNote, RejectedBy, RejectedAt, RejectNote, RevokedBy, RevokedAt, RevokeNote, CreatedAt, CreatedBy, UpdatedAt, UpdatedBy.
- In **SakuraDbContext**: register both as `.ToTable(..., "dbo")`. Do **not** include them in the romv read-only rule so SaveChanges can write.

**2. Create request API**

- **Request DTO:** WorkspaceId, RequestedFor, RequestedBy, LMApprover, RequestReason. Optional: RequestCode (if not generated).
- **Response DTO:** Id (or RequestId), RequestCode, RequestStatus.
- **Logic:** Get current user email from `HttpContext.User`. Insert one row into `dbo.PermissionRequests` (RequestStatus = 0, CreatedBy/UpdatedBy = user). Optionally insert one or two rows into `dbo.PermissionHeaders` (ApprovalStatus = 0, Approvers = "" or from config). Generate or validate RequestCode. Return id and RequestCode.
- **Endpoint:** `POST /api/permissions` (or `POST /api/workspaces/{workspaceId}/permissions`).
- **Validation:** WorkspaceId exists; required fields not empty; RequestCode unique if provided.

**3. Approve / Reject API (per header)**

- **Request DTOs:** Approve (optional Note), Reject (required Note).
- **Logic:** Get current user email. Load request + headers. Check: this header is Pending (ApprovalStatus = 1); user is LM (when RequestStatus = 0) or user is in this header’s Approvers (when OLS/RLS pending). Update the header: set ApprovalStatus, ApprovedBy/At/Note or RejectedBy/At/Note, UpdatedAt/UpdatedBy. Then set `dbo.PermissionRequests.RequestStatus` from the two headers (e.g. both approved → 3, any rejected → 4). Save.
- **Endpoints:**  
  `POST /api/permissions/requests/{permissionRequestId}/headers/{headerId}/approve`  
  `POST /api/permissions/requests/{permissionRequestId}/headers/{headerId}/reject`
- **Responses:** 403 if user not allowed, 400 if wrong state.

**4. List response (after DB view change)**

- Add **RequestCode** and **LMApprover** to **PermissionRequestsResponse** and to the mapping from the view so the list API returns them.

---

## e) Frontend changes

**1. Service and config**

- **permission-request.model.ts:** Add `CreatePermissionRequestRequest` (WorkspaceId, RequestedFor, RequestedBy, LMApprover, RequestReason, optional RequestCode). Add create response type (e.g. id, requestCode, requestStatus).
- **permission-request.service.ts:**  
  - `createRequest(req): Observable<...>` → POST create endpoint.  
  - `approveHeader(permissionRequestId, headerId, note?)`: POST approve.  
  - `rejectHeader(permissionRequestId, headerId, note)`: POST reject.
- **backend-endpoints.config.ts:** Add POST create path and POST approve/reject paths (with permissionRequestId and headerId in path).

**2. Tabular create screen**

- New route, e.g. `wso-console/permission-requests/create` (or a “New request” button that opens it).
- Form: Workspace (dropdown), RequestedFor, RequestedBy, LMApprover, RequestReason. Submit → `createRequest(...)`. Success: toast + go to list or refresh list. Error: show message (e.g. duplicate RequestCode).
- Use existing workspace list for the dropdown.

**3. Details modal: Approve / Reject**

- In **permission-headers-modal**: for each header with `approvalStatus === 1`, show **Approve** and **Reject**.
- Approve: optional note, then `approveHeader(requestId, header.id, note)`; then refresh details (and list if needed); toast.
- Reject: required reason, then `rejectHeader(...)`; same refresh and toast.
- Show buttons only when the current user is allowed (if backend doesn’t send a flag, you can hide for now or match same rules as backend: LM for PendingLM, or in Approvers for that header).

**4. List (after backend returns RequestCode/LMApprover)**

- Add **RequestCode** and **LMApprover** to the list model and table columns if you want them visible.

---

## Summary checklist

| Layer   | What to do |
|---------|------------|
| **DB**  | Add RequestCode, LMApprover to view `romv.PermissionRequests`. |
| **BE**  | PermissionRequestRow + PermissionHeaderRow → dbo; POST create; POST approve/reject per header; add RequestCode/LMApprover to list response. |
| **FE**  | createRequest, approveHeader, rejectHeader + endpoint config; tabular create form; Approve/Reject buttons in details modal; optional list columns. |

That’s the full plan and all changes for **Create request (tabular) and single-step approval** only.
