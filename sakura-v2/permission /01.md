# 1. Create Request (Tabular) and Single-Step Approval

One document: principles → data load reference → plan → roadmap → DB → backend → frontend. Only what’s needed for **tabular create** and **approve/reject one request at a time**.

---

## Principles (must be clear)

1. **Scripts bypass the approval flow.**  
   The populate scripts (`0-Global Script.sql`, `1-CDI Script.sql`, etc.) insert data with **RequestStatus = 3 (Approved)** and **ApprovalStatus = 2 (Approved)**. That is for **seed/demo data only**. The scripts do not run the real workflow (LM → OLS → RLS). They are not a model for how new requests should be created in the app.

2. **Tabular entry does NOT bypass the approval flow.**  
   The new “create request (tabular)” feature is there to help users do **correct data entry** for each and every workspace. It creates a request in **Pending LM** (RequestStatus = 0). That request **must then go through the full approval flow**: LM → OLS → RLS. No back door. Tabular entry only makes it easier to enter the right fields (Workspace, RequestedFor, RequestedBy, LMApprover, RequestReason) so the request is ready for approval—it does not skip any approval step.

---

## Data load (how it works today — reference only)

The scripts write the same tables and columns the app will use. The difference is **state**: scripts insert already-approved state; the app creates pending state and then approvals move it forward.

**Scripts:** `Script_Populate/0-Global Script.sql` inserts into `PermissionRequests` and `PermissionHeaders`. `Script_Populate/1-CDI Script.sql` (and 1-AMER, 1-GI, etc.) insert into `RLSPermission*Details` by joining on `PermissionRequests.RequestCode` → `PermissionHeaders` → `RLSPermissions`.

**Insert order in 0-Global Script.sql:**

| Step | Table | Key columns (example) |
|------|--------|------------------------|
| 1 | `dbo.PermissionRequests` | RequestCode (e.g. REQCD10001), WorkspaceId, RequestedFor, RequestedBy, **LMApprover** (from refv.Employees parent or RequestedFor), RequestStatus (0–6), RequestReason, CreatedAt, CreatedBy, UpdatedAt, UpdatedBy |
| 2 | `dbo.PermissionHeaders` | PermissionRequestId (= pr.Id), PermissionType (0=OLS, 1=RLS), ApprovalStatus (0–5), Approvers, ApprovedBy, ApprovedAt, ApproveNote, RejectedBy, RejectedAt, RejectNote, … |
| 3 | `dbo.OLSPermissions` / `dbo.RLSPermissions` | PermissionHeaderId, … |
| 4 | (in 1-CDI etc.) `RLSPermissionCDIDetails` | RLSPermissionsId, EntityKey, ClientKey, SLKey, … (joined via pr.RequestCode) |

**Scripts = bypass:** In the script, requests are inserted with **RequestStatus = 3 (Approved)** and headers with **ApprovalStatus = 2 (Approved)**. So the approval flow is skipped (seed data only).

**One example (CDI):** Request **REQCD10001** in the script → one row in `PermissionRequests` (RequestStatus=3 Approved), one row in `PermissionHeaders` (PermissionType=1 RLS, ApprovalStatus=2 Approved). Then 1-CDI inserts RLS detail rows. No LM/OLS/RLS approval steps are run.

**App (tabular + approval):** Tabular create inserts **one row** into `PermissionRequests` with **RequestStatus = 0 (Pending LM)** and optionally 1–2 rows into `PermissionHeaders` with **ApprovalStatus = 0 (Not started)** or 1 (Pending). The request then goes through the normal flow: LM approves → OLS (if any) → RLS (if any). Approve/Reject API updates the header and request status; no bypass.

---

## a) Plan end-to-end

1. **Create (tabular):** User picks workspace, fills RequestedFor, RequestedBy, LMApprover, RequestReason; submits. Backend inserts **one row** into `dbo.PermissionRequests` with **RequestStatus = 0 (Pending LM)** and optionally 1–2 rows into `dbo.PermissionHeaders` (ApprovalStatus = 0 or 1). The request **does not skip approval**—it is now waiting for LM (then OLS/RLS as applicable). Tabular entry is only for correct data entry per workspace; the request then goes through the full LM → OLS → RLS flow.
2. **Details:** User opens the request (existing modal). Sees request + OLS/RLS headers. If the current user is the **LM** (RequestStatus=0) or is in a header’s **Approvers** and that header is **Pending** (ApprovalStatus=1), show **Approve** and **Reject** for that header.
3. **Approve/Reject:** User clicks, enters note (required for Reject). Backend updates that row in `dbo.PermissionHeaders` (ApprovalStatus, ApprovedBy/RejectedBy, note), then updates `dbo.PermissionRequests.RequestStatus` from the headers. Modal and list refresh. The approval flow is always followed; no bypass.

**In scope:** Tabular create API + UI (correct entry only; request starts as Pending LM); single-header approve/reject API + buttons in details modal.  
**Out of scope here:** Wizard submit, “pending for me” list, batch approve, history, delegates, existing rights, email deep link.

---

## b) Roadmap (order of work)

| Step | What |
|------|------|
| 1 | DB: add RequestCode, LMApprover to list view (so list can show them). |
| 2 | Backend: entities for base tables (write); create API; approve/reject API. |
| 3 | Frontend: create API + tabular create screen; approve/reject API + buttons in modal. |

DB first (view change). Then backend (write entities + two APIs). Then frontend (new screen + modal actions).

---

## c) DB changes

**Only one change:**

- **View `romv.PermissionRequests`**  
  Today it returns: RequestId, WorkspaceId, RequestedBy, RequestedFor, RequestStatus, OLSStatus, RLSStatus.  
  **Add to the view:** `RequestCode`, `LMApprover` from `dbo.PermissionRequests` (add to SELECT and to GROUP BY if you keep GROUP BY).

No new tables. No changes to `dbo.PermissionRequests`, `dbo.PermissionHeaders`, or `romv.PermissionHeaders`.

---

## d) Backend changes

**1. Writable entities (so we can insert/update, not only read views)**

- New entity **PermissionRequestRow** → table `dbo.PermissionRequests`: Id, RequestCode, RequestedFor, RequestedBy, LMApprover, RequestStatus, RequestReason, WorkspaceId, CreatedAt, CreatedBy, UpdatedAt, UpdatedBy.
- New entity **PermissionHeaderRow** → table `dbo.PermissionHeaders`: Id, PermissionRequestId, PermissionType, ApprovalStatus, Approvers, ApprovedBy, ApprovedAt, ApproveNote, RejectedBy, RejectedAt, RejectNote, RevokedBy, RevokedAt, RevokeNote, CreatedAt, CreatedBy, UpdatedAt, UpdatedBy.
- In **SakuraDbContext**: register both as `.ToTable(..., "dbo")`. Do **not** include them in the romv read-only rule so SaveChanges can write.

**2. Create request API (no bypass of approval flow)**

- **Request DTO:** WorkspaceId, RequestedFor, RequestedBy, LMApprover, RequestReason. Optional: RequestCode (if not generated).
- **Response DTO:** Id (or RequestId), RequestCode, RequestStatus.
- **Logic:** Get current user email from `HttpContext.User`. Insert one row into `dbo.PermissionRequests` with **RequestStatus = 0 (Pending LM)** and CreatedBy/UpdatedBy = user. Optionally insert one or two rows into `dbo.PermissionHeaders` with **ApprovalStatus = 0 (Not started)** or 1 (Pending); Approvers from config or empty. Generate or validate RequestCode. Return id and RequestCode. **Do not** set RequestStatus=3 (Approved) or ApprovalStatus=2 (Approved) on create—the request must go through the real approval flow.
- **Endpoint:** `POST /api/permissions` (or `POST /api/workspaces/{workspaceId}/permissions`).
- **Validation:** WorkspaceId exists; required fields not empty; RequestCode unique if provided.

**3. Approve / Reject API (per header)**

- **Request DTOs:** Approve (optional Note), Reject (required Note).
- **Logic:** Get current user email. Load request + headers. Check: this header is Pending (ApprovalStatus = 1); user is LM (when RequestStatus = 0) or user is in this header’s Approvers (when OLS/RLS pending). Update the header: set ApprovalStatus, ApprovedBy/At/Note or RejectedBy/At/Note, UpdatedAt/UpdatedBy. Then set `dbo.PermissionRequests.RequestStatus` from the two headers (e.g. both approved → 3, any rejected → 4). Save.
- **Endpoints:**  
  `POST /api/permissions/requests/{permissionRequestId}/headers/{headerId}/approve`  
  `POST /api/permissions/requests/{permissionRequestId}/headers/{headerId}/reject`
- **Responses:** 403 if user not allowed, 400 if wrong state.

**4. List response (after DB view change)**

- Add **RequestCode** and **LMApprover** to **PermissionRequestsResponse** and to the mapping from the view so the list API returns them.

---

## e) Frontend changes

**1. Service and config**

- **permission-request.model.ts:** Add `CreatePermissionRequestRequest` (WorkspaceId, RequestedFor, RequestedBy, LMApprover, RequestReason, optional RequestCode). Add create response type (e.g. id, requestCode, requestStatus).
- **permission-request.service.ts:**  
  - `createRequest(req): Observable<...>` → POST create endpoint.  
  - `approveHeader(permissionRequestId, headerId, note?)`: POST approve.  
  - `rejectHeader(permissionRequestId, headerId, note)`: POST reject.
- **backend-endpoints.config.ts:** Add POST create path and POST approve/reject paths (with permissionRequestId and headerId in path).

**2. Tabular create screen**

- New route, e.g. `wso-console/permission-requests/create` (or a “New request” button that opens it).
- Purpose: help users do **correct data entry** per workspace (right workspace, RequestedFor, RequestedBy, LMApprover, RequestReason). The created request will be **Pending LM** and must go through the full approval flow—no bypass.
- Form: Workspace (dropdown), RequestedFor, RequestedBy, LMApprover, RequestReason. Submit → `createRequest(...)`. Success: toast + go to list or refresh list. Error: show message (e.g. duplicate RequestCode).
- Use existing workspace list for the dropdown.

**3. Details modal: Approve / Reject**

- In **permission-headers-modal**: for each header with `approvalStatus === 1`, show **Approve** and **Reject**.
- Approve: optional note, then `approveHeader(requestId, header.id, note)`; then refresh details (and list if needed); toast.
- Reject: required reason, then `rejectHeader(...)`; same refresh and toast.
- Show buttons only when the current user is allowed (if backend doesn’t send a flag, you can hide for now or match same rules as backend: LM for PendingLM, or in Approvers for that header).

**4. List (after backend returns RequestCode/LMApprover)**

- Add **RequestCode** and **LMApprover** to the list model and table columns if you want them visible.

---

## Summary checklist

| Layer   | What to do |
|---------|------------|
| **DB**  | Add RequestCode, LMApprover to view `romv.PermissionRequests`. |
| **BE**  | PermissionRequestRow + PermissionHeaderRow → dbo; POST create; POST approve/reject per header; add RequestCode/LMApprover to list response. |
| **FE**  | createRequest, approveHeader, rejectHeader + endpoint config; tabular create form; Approve/Reject buttons in details modal; optional list columns. |

That’s the full plan and all changes for **Create request (tabular) and single-step approval** only.
