# Sakura Backend - Mermaid Diagrams Documentation

## Table of Contents
1. [Entity Relationship Diagrams](#entity-relationship-diagrams)
2. [Class Diagrams](#class-diagrams)
3. [Sequence Diagrams](#sequence-diagrams)
4. [Architecture Diagrams](#architecture-diagrams)

---

## 1. Entity Relationship Diagrams

### 1.1 Complete Database Schema

```mermaid
erDiagram
    Workspace ||--o{ WorkspaceApp : "contains"
    SecurityModel ||--o{ SecurityDimension : "has"
    SecurityModel ||--o{ SecurityModelTypeMapping : "maps to"
    
    Workspace {
        int Id PK "Primary key - unique workspace identifier"
        string WorkspaceName "Display name for workspace"
        string WorkspaceCode UK "Unique business code for workspace"
        string WorkspaceOwner "Email of business owner"
        string WorkspaceTechOwner "Email of technical owner"
        string WorkspaceApprover "Email of default approver"
        string WorkspaceEntraGroupUID "Azure Entra Group GUID for access control"
        string WorkspaceTag "Tags for categorization"
        bool IsActive "Soft delete flag - true means active"
        string CreatedBy "Email of user who created record"
        datetime CreatedAt "Timestamp when record was created"
        string UpdatedBy "Email of user who last updated"
        datetime UpdatedAt "Timestamp of last update - used for concurrency"
    }
    
    WorkspaceApp {
        int Id PK "Primary key - unique app identifier"
        int WorkspaceId FK "Foreign key to parent workspace"
        string AppCode "Unique code for application within workspace"
        string AppName "Display name of application"
        string AppOwner "Email of application business owner"
        string AppTechnicalOwner "Email of application technical owner"
        string AppEntraGroupUID "Azure Entra Group GUID for app access"
        int OLSMode "Object Level Security mode: 0=Managed, 1=Unmanaged"
        int ApprovalMode "Approval type: 0=AppBased, 1=AudienceBased"
        string Approvers "Comma-separated list of approver emails"
        string AdditionalQuestionsJSON "Custom approval questions in JSON format"
        bool IsActive "Soft delete flag - true means active"
        string CreatedBy "Email of user who created record"
        datetime CreatedAt "Timestamp when record was created"
        string UpdatedBy "Email of user who last updated"
        datetime UpdatedAt "Timestamp of last update"
    }
    
    SecurityModel {
        int Id PK "Primary key - unique security model identifier"
        int WorkspaceId "Workspace this security model belongs to"
        string ModelCode UK "Unique uppercase code for security model"
        string ModelName "Display name of security model"
        string Description "Optional description of model purpose"
        bool IsActive "Soft delete flag - true means active"
        string CreatedBy "Email of user who created record"
        datetime CreatedAt "Timestamp when record was created"
        string UpdatedBy "Email of user who last updated"
        datetime UpdatedAt "Timestamp of last update"
    }
    
    SecurityDimension {
        int Id PK "Primary key - unique dimension identifier"
        int SecurityModelId FK "Foreign key to parent security model - cascades delete"
        string DimensionCode "Unique code for dimension within model"
        string DimensionName "Display name of dimension"
        string SourceTable "Database table containing dimension data"
        int DimensionType "Type identifier for dimension category"
        bool IsActive "Soft delete flag - true means active"
        string CreatedBy "Email of user who created record"
        datetime CreatedAt "Timestamp when record was created"
        string UpdatedBy "Email of user who last updated"
        datetime UpdatedAt "Timestamp of last update"
    }
    
    SecurityModelTypeMapping {
        int Id PK "Primary key - unique mapping identifier"
        int SecurityModelId FK "Foreign key to security model - cascades delete"
        string SecurityTypeCode "References LoVs table where LovType=SecurityType"
        string CreatedBy "Email of user who created record"
        datetime CreatedAt "Timestamp when record was created"
        string UpdatedBy "Email of user who last updated"
        datetime UpdatedAt "Timestamp of last update"
    }
    
    LoVs {
        int Id PK "Primary key - unique LoV identifier"
        string LovType "Category of value - groups related LoVs"
        string LoVValue "Code value used in system logic"
        string LoVName "Display name shown to users"
        string LoVDescription "Description of value meaning"
        string ParentLoVType "Parent category for hierarchical LoVs"
        string ParentLoVValue "Parent value for hierarchical relationships"
        datetime CreatedAt "Timestamp when record was created"
        string CreatedBy "Email of user who created record"
        datetime UpdatedAt "Timestamp of last update"
        string UpdatedBy "Email of user who last updated"
    }
    
    RefreshToken {
        int TokenId PK "Primary key - unique token identifier"
        string Token UK "SHA256 hash of refresh token"
        string UserId "User identifier - email or Azure AD sub"
        datetime CreatedAt "Timestamp when token was created"
        datetime ExpiresAt "Timestamp when token expires - 7 days default"
        string CreatedByIp "IP address of client that created token"
        bool Revoked "Flag indicating if token has been revoked"
        datetime RevokedAt "Timestamp when token was revoked"
    }
```

### 1.2 Core Workspace Domain

```mermaid
erDiagram
    Workspace ||--o{ WorkspaceApp : "owns applications"
    
    Workspace {
        int Id "Unique identifier"
        string WorkspaceCode "Business code - must be unique"
        string WorkspaceName "Display name"
    }
    
    WorkspaceApp {
        int Id "Unique identifier"
        int WorkspaceId "Links to parent workspace"
        string AppCode "Application code"
        string AppName "Application display name"
        int OLSMode "Security mode - Managed or Unmanaged"
        int ApprovalMode "Approval type - App or Audience based"
    }
```

### 1.3 Security Model Domain

```mermaid
erDiagram
    SecurityModel ||--o{ SecurityDimension : "defines dimensions"
    SecurityModel ||--o{ SecurityModelTypeMapping : "applies to types"
    SecurityModelTypeMapping }o--|| LoVs : "references"
    
    SecurityModel {
        int Id "Unique identifier"
        string ModelCode "Business code - uppercase"
        string ModelName "Display name"
        int WorkspaceId "Associated workspace"
    }
    
    SecurityDimension {
        int Id "Unique identifier"
        string DimensionCode "Dimension code - e.g. REGION"
        string DimensionName "Display name - e.g. Sales Region"
        string SourceTable "Source data table"
    }
    
    SecurityModelTypeMapping {
        int Id "Unique identifier"
        string SecurityTypeCode "Links to LoVs SecurityType"
    }
    
    LoVs {
        string LovType "Category - e.g. SecurityType"
        string LoVValue "Code - e.g. RLS"
        string LoVName "Display - e.g. Row Level Security"
    }
```

---

## 2. Class Diagrams

### 2.1 Domain Layer - Entity Hierarchy

```mermaid
classDiagram
    class IEntity~TKey~ {
        <<interface>>
        +TKey Id
    }
    
    class IAuditable {
        <<interface>>
        +string CreatedBy
        +DateTime CreatedAt
        +string UpdatedBy
        +DateTime UpdatedAt
    }
    
    class ISoftDeletable {
        <<interface>>
        +bool IsActive
    }
    
    class SakuraEntity~TKey~ {
        <<abstract>>
        +TKey Id "Primary key - provides identity"
        +Equals(object obj) bool "Compares entities by ID"
        +GetHashCode() int "Hash based on ID"
    }
    
    class SakuraAuditableEntity {
        <<abstract>>
        +string CreatedBy "User who created - email"
        +DateTime CreatedAt "Creation timestamp - UTC"
        +string UpdatedBy "User who last modified - email"
        +DateTime UpdatedAt "Last modification timestamp - used for concurrency token"
    }
    
    class Workspace {
        +int Id "Primary key"
        +string WorkspaceName "Display name - required"
        +string WorkspaceCode "Unique code - required, alphanumeric + underscore"
        +string WorkspaceOwner "Business owner email - required"
        +string WorkspaceTechOwner "Technical owner email - required"
        +string WorkspaceApprover "Default approver email - required"
        +string WorkspaceEntraGroupUID "Azure Entra Group GUID - optional"
        +string WorkspaceTag "Tags for categorization - optional"
        +bool IsActive "Soft delete flag - true = active"
        +ICollection~WorkspaceApp~ Apps "Child applications"
    }
    
    class WorkspaceApp {
        +int Id "Primary key"
        +string AppCode "Application code - required"
        +string AppName "Display name - required"
        +string AppOwner "Business owner - required"
        +string AppTechnicalOwner "Technical owner - required"
        +string AppEntraGroupUID "Azure Entra Group GUID"
        +OLSMode OLSMode "Security mode - Managed or Unmanaged"
        +ApprovalMode ApprovalMode "Approval type - AppBased or AudienceBased"
        +string Approvers "Comma-separated approver emails - stored in DB"
        +IList~string~ ApproversList "Parsed approver list - not mapped to DB"
        +string AdditionalQuestionsJSON "Custom questions - JSON format"
        +bool IsActive "Soft delete flag"
        +int WorkspaceId "Foreign key to Workspace"
        +Workspace Workspace "Parent workspace navigation"
        +AddApprover(string email) void "Adds email to approvers list if not exists"
        +RemoveApprover(string email) bool "Removes email from approvers list"
    }
    
    class SecurityModel {
        +int Id "Primary key"
        +int WorkspaceId "Associated workspace"
        +string ModelCode "Unique code - uppercase"
        +string ModelName "Display name - required"
        +string Description "Optional description"
        +bool IsActive "Soft delete flag"
        +ICollection~SecurityDimension~ SecurityDimensions "Dimensions in this model"
        +ICollection~SecurityModelTypeMapping~ SecurityTypeMappings "Security types"
    }
    
    class SecurityDimension {
        +int Id "Primary key"
        +int SecurityModelId "Parent model - cascades delete"
        +string DimensionCode "Dimension code - required"
        +string DimensionName "Display name - required"
        +string SourceTable "Source table name - optional"
        +int DimensionType "Type identifier"
        +bool IsActive "Soft delete flag"
        +SecurityModel SecurityModel "Parent navigation"
    }
    
    class SecurityModelTypeMapping {
        +int Id "Primary key"
        +int SecurityModelId "Parent model - cascades delete"
        +string SecurityTypeCode "References LoVs.LoVValue - SecurityType category"
        +SecurityModel SecurityModel "Parent navigation"
    }
    
    class LoVs {
        +int LoVId "Primary key"
        +string LovType "Category - e.g. SecurityType, ApproverLevel"
        +string LoVValue "Code value - used in logic"
        +string LoVName "Display name - shown to users"
        +string LoVDescription "Description"
        +string ParentLoVType "Parent category - for hierarchical LoVs"
        +string ParentLoVValue "Parent value - links to parent"
        +DateTime CreatedAt "Creation timestamp"
        +string CreatedBy "Creator email"
        +DateTime UpdatedAt "Last update timestamp"
        +string UpdatedBy "Last updater email"
    }
    
    class User {
        +string Id "User GUID"
        +string UserName "Username - for local auth"
        +byte[] PasswordHash "Hashed password - SHA256"
        +byte[] PasswordSalt "Password salt - random bytes"
        +bool IsActive "Active flag - can login if true"
        +string Email "User email"
        +DateTime CreatedAt "Registration date"
    }
    
    class RefreshToken {
        +int TokenId "Primary key"
        +string Token "SHA256 hash of refresh token - not plain text"
        +string UserId "User identifier - links to User"
        +DateTime CreatedAt "Token creation time"
        +DateTime ExpiresAt "Token expiration time - 7 days default"
        +string CreatedByIp "Client IP address"
        +bool Revoked "Revocation flag - true if revoked"
        +DateTime RevokedAt "Revocation timestamp"
    }
    
    IEntity~TKey~ <|.. SakuraEntity~TKey~ : implements
    IAuditable <|.. SakuraAuditableEntity : implements
    SakuraEntity~int~ <|-- SakuraAuditableEntity : extends
    SakuraAuditableEntity <|-- Workspace : extends
    SakuraAuditableEntity <|-- WorkspaceApp : extends
    SakuraAuditableEntity <|-- SecurityModel : extends
    SakuraAuditableEntity <|-- SecurityDimension : extends
    SakuraAuditableEntity <|-- SecurityModelTypeMapping : extends
    ISoftDeletable <|.. Workspace : implements
    ISoftDeletable <|.. WorkspaceApp : implements
    ISoftDeletable <|.. SecurityModel : implements
    ISoftDeletable <|.. SecurityDimension : implements
    Workspace "1" --> "*" WorkspaceApp : contains
    SecurityModel "1" --> "*" SecurityDimension : defines
    SecurityModel "1" --> "*" SecurityModelTypeMapping : maps
```

### 2.2 Application Layer - Request/Response Pattern

```mermaid
classDiagram
    class SakuraRequest {
        <<abstract>>
        +string ConcurrencyToken "HMAC-SHA256 token - validates no concurrent updates"
    }
    
    class SakuraCreateRequest {
        <<abstract>>
        +string CreatedBy "Email of user creating record - required"
    }
    
    class SakuraUpdateRequest {
        <<abstract>>
        +int Id "Entity ID to update - required"
        +string UpdatedBy "Email of user updating - required"
    }
    
    class SakuraDeleteRequest {
        <<abstract>>
        +int Id "Entity ID to delete - required"
        +string DeletedBy "Email of user deleting - required"
    }
    
    class CreateWorkspaceRequest {
        +string WorkspaceName "Display name - required"
        +string WorkspaceCode "Unique code - required"
        +string WorkspaceOwner "Owner email - required"
        +string WorkspaceTechOwner "Tech owner email - required"
        +string WorkspaceApprover "Approver email - required"
        +string WorkspaceEntraGroupUID "Azure Group GUID - optional"
        +string WorkspaceTag "Tags - optional"
    }
    
    class UpdateWorkspaceRequest {
        "Inherits all fields from CreateWorkspaceRequest plus Id and UpdatedBy"
    }
    
    class DeleteWorkspaceRequest {
        "Contains Id, DeletedBy, and ConcurrencyToken only"
    }
    
    class SakuraResponse {
        <<abstract>>
        +string ConcurrencyToken "Auto-computed from Id and UpdatedAt - sent to client"
    }
    
    class WorkspaceResponse {
        +int Id "Workspace identifier"
        +string WorkspaceName "Display name"
        +string WorkspaceCode "Unique code"
        +string WorkspaceOwner "Owner email"
        +string WorkspaceTechOwner "Tech owner email"
        +string WorkspaceApprover "Approver email"
        +string WorkspaceEntraGroupUID "Azure Group GUID"
        +string WorkspaceTag "Tags"
        +bool IsActive "Active flag"
        +DateTime CreatedAt "Creation timestamp"
        +string CreatedBy "Creator email"
        +DateTime UpdatedAt "Last update timestamp"
        +string UpdatedBy "Last updater email"
        +string ConcurrencyToken "Inherited - for optimistic locking"
    }
    
    class SecurityModelResponse {
        +int Id "Model identifier"
        +int WorkspaceId "Parent workspace ID"
        +string ModelCode "Unique uppercase code"
        +string ModelName "Display name"
        +string Description "Optional description"
        +List~string~ SecurityTypes "Security type codes"
        +List~SecurityDimensionResponse~ Dimensions "Child dimensions"
        +bool IsActive "Active flag"
        +DateTime CreatedAt "Creation timestamp"
        +string CreatedBy "Creator email"
        +DateTime ModifiedAt "Last update timestamp"
        +string ModifiedBy "Last updater email"
        +string ConcurrencyToken "Inherited"
    }
    
    class ApiBaseResult {
        +bool Success "True if request succeeded"
        +string Message "Human-readable message"
        +List~ErrorInfo~ Errors "Validation/business errors"
    }
    
    class ApiSingleResult~T~ {
        +T Data "Single entity response"
    }
    
    class ApiListResult~T~ {
        +List~T~ Data "List of entities"
        +int Count "Total count"
    }
    
    class ApiScalarResult~T~ {
        +T Value "Scalar value - bool, int, etc"
    }
    
    SakuraRequest <|-- SakuraCreateRequest : extends
    SakuraRequest <|-- SakuraUpdateRequest : extends
    SakuraRequest <|-- SakuraDeleteRequest : extends
    SakuraCreateRequest <|-- CreateWorkspaceRequest : extends
    SakuraUpdateRequest <|-- UpdateWorkspaceRequest : extends
    SakuraDeleteRequest <|-- DeleteWorkspaceRequest : extends
    SakuraResponse <|-- WorkspaceResponse : extends
    SakuraResponse <|-- SecurityModelResponse : extends
    ApiBaseResult <|-- ApiSingleResult~T~ : extends
    ApiBaseResult <|-- ApiListResult~T~ : extends
    ApiBaseResult <|-- ApiScalarResult~T~ : extends
```

### 2.3 Infrastructure Layer - Repository Pattern

```mermaid
classDiagram
    class ISakuraRepository~TEntity,TKey~ {
        <<interface>>
        +GetByIdAsync(TKey id) Task~TEntity~ "Retrieves entity by primary key"
        +GetAllAsync() Task~List~TEntity~~ "Gets all active entities - respects soft delete"
        +GetPagedAsync(int page, int size) Task~PagedList~TEntity~~ "Gets paginated results"
        +AddAsync(TEntity entity) Task~TEntity~ "Adds new entity"
        +Update(TEntity entity) void "Updates existing entity"
        +Delete(TKey id) void "Soft deletes entity - sets IsActive=false"
        +ExistsAsync(Expression predicate) Task~bool~ "Checks if entity exists"
        +FindAsync(Expression predicate) Task~List~TEntity~~ "Queries with condition"
    }
    
    class SakuraRepository~TEntity,TKey~ {
        -SakuraDbContext _context "Database context"
        -DbSet~TEntity~ _dbSet "Entity set"
        +GetByIdAsync(TKey id) Task~TEntity~ "Implements async retrieval"
        +GetAllAsync() Task~List~TEntity~~ "Implements list retrieval"
        +AddAsync(TEntity entity) Task~TEntity~ "Implements add operation"
        +Update(TEntity entity) void "Marks entity as modified"
        +Delete(TKey id) void "Triggers soft delete via DbContext"
    }
    
    class IUnitOfWork {
        <<interface>>
        +Repository~TEntity,TKey~() ISakuraRepository "Gets or creates repository instance"
        +SaveChangesAsync() Task~int~ "Commits transaction"
        +SaveChanges() int "Synchronous commit"
        +Dispose() void "Releases context"
    }
    
    class UnitOfWork {
        -SakuraDbContext _context "Database context"
        -Dictionary _repositories "Repository cache - one per entity type"
        +Repository~TEntity,TKey~() ISakuraRepository "Returns cached or new repo"
        +SaveChangesAsync() Task~int~ "Calls DbContext.SaveChangesAsync"
        +Dispose() void "Disposes context"
    }
    
    class SakuraDbContext {
        +DbSet~Workspace~ Workspaces "Workspace entity set"
        +DbSet~SecurityModel~ SecurityModels "Security model entity set"
        +DbSet~SecurityDimension~ SecurityDimensions "Dimension entity set"
        +DbSet~LoVs~ Lovs "LoV entity set"
        +DbSet~RefreshToken~ RefreshTokens "Refresh token entity set"
        +SaveChanges() int "Applies soft delete before saving"
        +SaveChangesAsync() Task~int~ "Async save with soft delete"
        -ApplySoftDeleteRules() void "Converts deletes to IsActive=false updates"
        -OnModelCreating() void "Configures entity mappings and query filters"
    }
    
    ISakuraRepository~TEntity,TKey~ <|.. SakuraRepository~TEntity,TKey~ : implements
    IUnitOfWork <|.. UnitOfWork : implements
    SakuraRepository~TEntity,TKey~ --> SakuraDbContext : uses
    UnitOfWork --> SakuraDbContext : owns
    UnitOfWork --> SakuraRepository~TEntity,TKey~ : creates
```

---

## 3. Sequence Diagrams

### 3.1 Workspace Creation Flow

```mermaid
sequenceDiagram
    participant Client as Frontend Client
    participant Controller as WorkspaceController
    participant Validator as FluentValidator
    participant Service as WorkspaceService
    participant Mapper as Mapster
    participant UoW as UnitOfWork
    participant Repo as Repository
    participant DbContext as SakuraDbContext
    participant DB as SQL Server
    
    Client->>Controller: POST /api/workspace (CreateWorkspaceRequest)
    Note over Client,Controller: Request contains: WorkspaceName, WorkspaceCode, Owner info, CreatedBy
    
    Controller->>Validator: Validate(request)
    Note over Validator: Checks: Required fields, Email format, Code format (alphanumeric+underscore)
    
    alt Invalid Request
        Validator-->>Controller: ValidationException
        Controller-->>Client: 400 Bad Request (validation errors)
    end
    
    Validator-->>Controller: Valid
    Controller->>Service: AddWorkspaceAsync(request)
    
    Service->>Repo: ExistsAsync(w => w.WorkspaceCode == request.WorkspaceCode)
    Note over Service,Repo: Checks uniqueness - soft-deleted records excluded by query filter
    Repo->>DbContext: Query with filter
    DbContext->>DB: SELECT WHERE WorkspaceCode=? AND IsActive=1
    DB-->>DbContext: Result
    DbContext-->>Repo: Entity or null
    Repo-->>Service: bool (exists)
    
    alt Code Already Exists
        Service-->>Controller: ValidationException (Duplicate code)
        Controller-->>Client: 400 Bad Request
    end
    
    Service->>Mapper: Map(request to Workspace entity)
    Note over Mapper: Creates entity, ignores audit fields
    Mapper-->>Service: Workspace entity
    
    Service->>Service: Stamp audit fields
    Note over Service: CreatedBy = request.CreatedBy<br/>CreatedAt = DateTime.UtcNow<br/>UpdatedBy = request.CreatedBy<br/>UpdatedAt = DateTime.UtcNow<br/>IsActive = true
    
    Service->>Repo: AddAsync(workspace)
    Repo->>DbContext: DbSet.AddAsync(workspace)
    DbContext-->>Repo: EntityEntry
    Repo-->>Service: workspace
    
    Service->>UoW: SaveChangesAsync()
    UoW->>DbContext: SaveChangesAsync()
    Note over DbContext: ApplySoftDeleteRules() called - no effect on inserts
    DbContext->>DB: INSERT INTO Workspaces VALUES (...)
    DB-->>DbContext: New Id (identity)
    DbContext-->>UoW: 1 (affected rows)
    UoW-->>Service: success
    
    Service->>Mapper: Map(workspace to WorkspaceResponse)
    Note over Mapper: Includes all fields + computes ConcurrencyToken
    Note over Mapper: Token = HMAC-SHA256(Id:UpdatedAtTicks)
    Mapper-->>Service: WorkspaceResponse
    
    Service-->>Controller: ApiSingleResult(WorkspaceResponse)
    Controller-->>Client: 200 OK { success: true, data: {...} }
    Note over Client: Client stores ConcurrencyToken for future updates
```

### 3.2 Workspace Update Flow with Concurrency Check

```mermaid
sequenceDiagram
    participant Client as Frontend Client
    participant Controller as WorkspaceController
    participant Service as WorkspaceService
    participant Repo as Repository
    participant DbContext as SakuraDbContext
    participant DB as SQL Server
    
    Client->>Controller: PUT /api/workspace (UpdateWorkspaceRequest)
    Note over Client,Controller: Request contains: Id, Updated fields, UpdatedBy, ConcurrencyToken
    
    Controller->>Service: UpdateWorkspaceAsync(request)
    
    Service->>Repo: GetByIdAsync(request.Id)
    Repo->>DbContext: Find(id)
    DbContext->>DB: SELECT WHERE Id=? AND IsActive=1
    DB-->>DbContext: Entity row
    DbContext-->>Repo: Workspace entity
    Repo-->>Service: workspace
    
    alt Not Found
        Service-->>Controller: NotFoundException
        Controller-->>Client: 404 Not Found
    end
    
    Service->>Service: CheckConcurrency(request, workspace)
    Note over Service: Compute expected token = HMAC-SHA256(Id:UpdatedAtTicks)<br/>Compare with request.ConcurrencyToken
    
    alt Token Mismatch
        Service-->>Controller: ValidationException
        Note over Controller: Error message includes: "Modified by X at Y UTC"
        Controller-->>Client: 400 Bad Request (Concurrency conflict)
    end
    
    Service->>Repo: ExistsAsync(w => w.WorkspaceCode == request.Code && w.Id != request.Id)
    Note over Service,Repo: Checks uniqueness excluding current record
    Repo-->>Service: bool (exists)
    
    alt Code Duplicate
        Service-->>Controller: ValidationException
        Controller-->>Client: 400 Bad Request (Duplicate code)
    end
    
    Service->>Service: Update entity properties
    Note over Service: WorkspaceName = request.WorkspaceName<br/>WorkspaceOwner = request.WorkspaceOwner<br/>etc...<br/>UpdatedBy = request.UpdatedBy<br/>UpdatedAt = DateTime.UtcNow
    
    Service->>Repo: Update(workspace)
    Repo->>DbContext: Entry(workspace).State = Modified
    
    Service->>DbContext: SaveChangesAsync()
    DbContext->>DB: UPDATE Workspaces SET ... WHERE Id=?
    DB-->>DbContext: 1 row affected
    DbContext-->>Service: success
    
    Service->>Service: Map to WorkspaceResponse
    Note over Service: Compute NEW ConcurrencyToken with new UpdatedAt
    
    Service-->>Controller: ApiSingleResult(WorkspaceResponse)
    Controller-->>Client: 200 OK { success: true, data: {..., concurrencyToken: "new_token" } }
    Note over Client: Client updates stored token with new value
```

### 3.3 Soft Delete Flow

```mermaid
sequenceDiagram
    participant Client as Frontend Client
    participant Controller as WorkspaceController
    participant Service as WorkspaceService
    participant Repo as Repository
    participant DbContext as SakuraDbContext
    participant DB as SQL Server
    
    Client->>Controller: PUT /api/workspace/delete (DeleteWorkspaceRequest)
    Note over Client,Controller: Request contains: Id, DeletedBy, ConcurrencyToken
    
    Controller->>Service: DeleteWorkspaceAsync(request)
    
    Service->>Repo: GetByIdAsync(request.Id)
    Repo-->>Service: workspace
    
    alt Not Found
        Service-->>Controller: NotFoundException
        Controller-->>Client: 404 Not Found
    end
    
    Service->>Service: CheckConcurrency(request, workspace)
    
    alt Token Mismatch
        Service-->>Controller: ValidationException
        Controller-->>Client: 400 Bad Request
    end
    
    alt Already Deleted (IsActive = false)
        Service-->>Controller: ValidationException ("Already deleted")
        Controller-->>Client: 400 Bad Request
    end
    
    Service->>Service: Stamp audit fields
    Note over Service: UpdatedBy = request.DeletedBy<br/>UpdatedAt = DateTime.UtcNow<br/>IsActive = false
    
    Service->>Repo: Delete(request.Id)
    Repo->>DbContext: Entry(workspace).State = Deleted
    
    Service->>DbContext: SaveChangesAsync()
    Note over DbContext: ApplySoftDeleteRules() intercepts delete
    DbContext->>DbContext: Change State to Modified<br/>Set IsActive = false
    DbContext->>DB: UPDATE Workspaces SET IsActive=0, UpdatedBy=?, UpdatedAt=? WHERE Id=?
    Note over DB: Record preserved - not deleted
    DB-->>DbContext: 1 row affected
    DbContext-->>Service: success
    
    Service-->>Controller: ApiScalarResult(true)
    Controller-->>Client: 200 OK { success: true, value: true }
```

### 3.4 Authentication Flow (Dev Mode)

```mermaid
sequenceDiagram
    participant Client as Frontend
    participant AuthCtrl as AuthController
    participant TempUser as TempUserService
    participant TokenSvc as TokenService
    participant Repo as AuthRepository
    participant DB as SQL Server
    
    Client->>AuthCtrl: POST /api/auth/login { email, password }
    
    AuthCtrl->>TempUser: AuthenticateUser(email, password)
    Note over TempUser: Loads temp-users.json<br/>Validates credentials
    
    alt Invalid Credentials
        TempUser-->>AuthCtrl: null
        AuthCtrl-->>Client: 401 Unauthorized
    end
    
    TempUser-->>AuthCtrl: User object (id, email, name, role, workspaceId, etc)
    
    AuthCtrl->>TokenSvc: GenerateAccessTokenWithUserInfo(userId, email, name, role, workspaceId, workspaceName, approverLevel)
    Note over TokenSvc: Creates JWT with claims<br/>Expiration: 8 hours<br/>Signs with secret key
    TokenSvc-->>AuthCtrl: JWT string
    
    AuthCtrl->>TokenSvc: GenerateRefreshTokenRaw()
    Note over TokenSvc: Generates 64-byte random token<br/>Base64 encodes
    TokenSvc-->>AuthCtrl: Raw refresh token
    
    AuthCtrl->>TokenSvc: ComputeHash(rawToken)
    Note over TokenSvc: SHA256 hash - for secure storage
    TokenSvc-->>AuthCtrl: Hash
    
    AuthCtrl->>TokenSvc: SaveRefreshTokenAsync(hash, userId, clientIP, expiresAt)
    TokenSvc->>Repo: SaveRefreshTokenAsync(...)
    Repo->>DB: INSERT INTO RefreshToken (Token, UserId, CreatedAt, ExpiresAt, CreatedByIp)
    DB-->>Repo: Success
    Repo-->>TokenSvc: Success
    TokenSvc-->>AuthCtrl: Success
    
    AuthCtrl->>AuthCtrl: Set HttpOnly cookie
    Note over AuthCtrl: Cookie: refreshToken=raw_token<br/>HttpOnly=true, Secure=true<br/>SameSite=None, Expires=7days
    
    AuthCtrl-->>Client: 200 OK { token, userId, email, name, role, workspaceId, workspaceName, approverLevel, expiresAt }
    Note over Client: Stores JWT in memory/localStorage<br/>Cookie stored by browser
```

### 3.5 Token Refresh Flow

```mermaid
sequenceDiagram
    participant Client as Frontend
    participant AuthCtrl as AuthController
    participant TokenSvc as TokenService
    participant Repo as AuthRepository
    participant DB as SQL Server
    
    Client->>AuthCtrl: POST /api/auth/refresh (Cookie: refreshToken)
    Note over Client: Access token expired - need refresh
    
    AuthCtrl->>AuthCtrl: Read refresh token from cookie
    
    alt No Cookie
        AuthCtrl-->>Client: 401 Unauthorized (No refresh token)
    end
    
    AuthCtrl->>TokenSvc: ComputeHash(rawToken)
    TokenSvc-->>AuthCtrl: Hash
    
    AuthCtrl->>TokenSvc: GetRefreshTokenByHashAsync(hash)
    TokenSvc->>Repo: GetRefreshTokenByHashAsync(hash)
    Repo->>DB: SELECT * FROM RefreshToken WHERE Token=?
    DB-->>Repo: RefreshToken row
    Repo-->>TokenSvc: RefreshToken entity
    TokenSvc-->>AuthCtrl: RefreshToken
    
    alt Token Not Found or Expired or Revoked
        AuthCtrl-->>Client: 401 Unauthorized (Invalid refresh token)
    end
    
    AuthCtrl->>TokenSvc: GenerateAccessToken(storedToken.UserId)
    Note over TokenSvc: Creates new JWT<br/>8 hours expiration
    TokenSvc-->>AuthCtrl: New JWT
    
    AuthCtrl->>TokenSvc: GenerateRefreshTokenRaw()
    TokenSvc-->>AuthCtrl: New raw token
    
    AuthCtrl->>TokenSvc: ComputeHash(newRawToken)
    TokenSvc-->>AuthCtrl: New hash
    
    AuthCtrl->>TokenSvc: RevokeRefreshTokenAsync(oldHash)
    Note over TokenSvc: Marks old token as revoked
    TokenSvc->>Repo: RevokeRefreshTokenAsync(oldHash)
    Repo->>DB: UPDATE RefreshToken SET Revoked=1, RevokedAt=? WHERE Token=?
    DB-->>Repo: Success
    Repo-->>TokenSvc: Success
    TokenSvc-->>AuthCtrl: Success
    
    AuthCtrl->>TokenSvc: SaveRefreshTokenAsync(newHash, userId, clientIP, expiresAt)
    TokenSvc->>Repo: SaveRefreshTokenAsync(...)
    Repo->>DB: INSERT INTO RefreshToken (...)
    DB-->>Repo: Success
    Repo-->>TokenSvc: Success
    TokenSvc-->>AuthCtrl: Success
    
    AuthCtrl->>AuthCtrl: Update refresh token cookie
    Note over AuthCtrl: Cookie: refreshToken=new_raw_token<br/>Same security settings
    
    AuthCtrl-->>Client: 200 OK { success: true, accessToken: "new_jwt" }
    Note over Client: Updates stored JWT<br/>Cookie updated by browser
```

---

## 4. Architecture Diagrams

### 4.1 System Architecture - Clean Architecture Layers

```mermaid
graph TD
    subgraph "Presentation Layer"
        A[Angular Frontend]
        B[Swagger UI]
    end
    
    subgraph "API Layer - Dentsu.SakuraApi"
        C[Controllers - REST endpoints]
        D[Middleware - Exception handling, headers]
        E[Action Filters - Validation]
    end
    
    subgraph "Application Layer - Dentsu.Sakura.Application"
        F[Services - Business logic orchestration]
        G[DTOs - Data transfer objects]
        H[Validators - FluentValidation rules]
        I[Mapster - Object mapping]
        J[Requests - Command models]
        K[Responses - Query results]
    end
    
    subgraph "Domain Layer - Dentsu.Sakura.Domain"
        L[Entities - Domain models with business rules]
        M[Interfaces - Contracts for repositories and services]
        N[Enums - Domain enumerations]
    end
    
    subgraph "Infrastructure Layer - Dentsu.Sakura.Infrastructure"
        O[DbContext - EF Core database context]
        P[Repositories - Data access implementation]
        Q[UnitOfWork - Transaction management]
    end
    
    subgraph "External Services"
        R[SQL Server - Database]
        S[Azure Key Vault - Secrets]
        T[Azure AD - Authentication]
    end
    
    A -->|HTTP/JSON| C
    B -->|HTTP| C
    C --> D
    D --> E
    E --> F
    F --> H
    F --> I
    F --> J
    F --> K
    F --> M
    H --> G
    I --> L
    J --> G
    K --> G
    M --> L
    M --> N
    P --> O
    Q --> O
    F --> P
    F --> Q
    O --> R
    C --> S
    C --> T
    
    style A fill:#e1f5ff
    style B fill:#e1f5ff
    style C fill:#fff4e6
    style D fill:#fff4e6
    style E fill:#fff4e6
    style F fill:#e8f5e9
    style G fill:#e8f5e9
    style H fill:#e8f5e9
    style I fill:#e8f5e9
    style J fill:#e8f5e9
    style K fill:#e8f5e9
    style L fill:#f3e5f5
    style M fill:#f3e5f5
    style N fill:#f3e5f5
    style O fill:#fce4ec
    style P fill:#fce4ec
    style Q fill:#fce4ec
    style R fill:#ffebee
    style S fill:#ffebee
    style T fill:#ffebee
```

### 4.2 Request Processing Pipeline

```mermaid
flowchart TD
    Start([HTTP Request]) --> Auth{Authentication<br/>Valid Token?}
    Auth -->|No| Unauth[401 Unauthorized]
    Auth -->|Yes| CORS{CORS<br/>Check}
    CORS -->|Fail| CORSError[403 Forbidden]
    CORS -->|Pass| Route{Route<br/>Exists?}
    Route -->|No| NotFound[404 Not Found]
    Route -->|Yes| ModelVal{Model<br/>Validation}
    ModelVal -->|Fail| ValError[400 Bad Request<br/>Validation Errors]
    ModelVal -->|Pass| ActionFilter[Action Filters<br/>ValidateActionParameters]
    ActionFilter --> Controller[Controller Method]
    Controller --> Service[Application Service]
    Service --> BizRules{Business<br/>Rules}
    BizRules -->|Fail| BizError[400 Bad Request<br/>Business Error]
    BizRules -->|Pass| Concurrency{Concurrency<br/>Check}
    Concurrency -->|Conflict| ConcError[400 Bad Request<br/>Concurrency Conflict]
    Concurrency -->|Pass| Repo[Repository]
    Repo --> UoW[Unit of Work]
    UoW --> DbContext[DbContext]
    DbContext --> SoftDelete{Soft Delete<br/>Interceptor}
    SoftDelete -->|Delete Op| Convert[Convert to<br/>IsActive=false]
    SoftDelete -->|Other Op| SaveDB[Save to Database]
    Convert --> SaveDB
    SaveDB --> MapResponse[Map to Response DTO<br/>Compute Concurrency Token]
    MapResponse --> Success[200 OK<br/>JSON Response]
    
    Unauth --> ExHandler[Global Exception<br/>Handler Middleware]
    CORSError --> ExHandler
    NotFound --> ExHandler
    ValError --> ExHandler
    BizError --> ExHandler
    ConcError --> ExHandler
    ExHandler --> ErrorResponse[Error Response<br/>with TraceId]
    
    style Start fill:#e3f2fd
    style Success fill:#c8e6c9
    style ErrorResponse fill:#ffcdd2
    style Auth fill:#fff9c4
    style CORS fill:#fff9c4
    style Route fill:#fff9c4
    style ModelVal fill:#fff9c4
    style BizRules fill:#fff9c4
    style Concurrency fill:#fff9c4
    style SoftDelete fill:#fff9c4
```

### 4.3 Dependency Injection Container

```mermaid
graph TB
    subgraph "Startup - Program.cs"
        A[Configure Services]
    end
    
    subgraph "Service Registrations"
        B[DbContext - Scoped<br/>Connection from Key Vault]
        C[Repositories - Scoped<br/>ISakuraRepository]
        D[UnitOfWork - Scoped<br/>IUnitOfWork]
        E[Services - Scoped<br/>IWorkspaceService, ISecurityModelService, etc]
        F[Validators - Scoped<br/>Auto-registered by FluentValidation]
        G[Mapster - Singleton<br/>IObjectMapper]
        H[TokenService - Scoped<br/>ITokenService]
        I[SecretProvider - Singleton<br/>ISecretProvider]
    end
    
    subgraph "Controllers"
        J[WorkspaceController<br/>Injects IWorkspaceService]
        K[SecurityController<br/>Injects ISecurityModelService]
        L[AuthController<br/>Injects ITokenService, IAuthRepository]
        M[AdminController<br/>Injects IManageLoVService]
    end
    
    A --> B
    A --> C
    A --> D
    A --> E
    A --> F
    A --> G
    A --> H
    A --> I
    
    B --> C
    B --> D
    C --> D
    D --> E
    E --> G
    E --> F
    I --> B
    I --> H
    
    E --> J
    E --> K
    H --> L
    C --> L
    E --> M
    
    style A fill:#e1f5ff
    style B fill:#fff4e6
    style C fill:#fff4e6
    style D fill:#fff4e6
    style E fill:#e8f5e9
    style F fill:#e8f5e9
    style G fill:#e8f5e9
    style H fill:#e8f5e9
    style I fill:#fce4ec
    style J fill:#f3e5f5
    style K fill:#f3e5f5
    style L fill:#f3e5f5
    style M fill:#f3e5f5
```

### 4.4 Data Flow - Read vs Write

```mermaid
graph LR
    subgraph "Read Flow - GET Requests"
        A1[Client] -->|HTTP GET| B1[Controller]
        B1 --> C1[Service]
        C1 --> D1[Repository]
        D1 --> E1[DbContext<br/>+ Query Filter]
        E1 --> F1[Database<br/>WHERE IsActive=1]
        F1 -->|Entities| E1
        E1 -->|Entities| D1
        D1 -->|Entities| C1
        C1 --> G1[Mapster<br/>Entity → DTO<br/>Compute Token]
        G1 -->|Response DTO| C1
        C1 -->|Response| B1
        B1 -->|JSON| A1
    end
    
    subgraph "Write Flow - POST/PUT Requests"
        A2[Client] -->|HTTP POST/PUT| B2[Controller]
        B2 --> C2[FluentValidator]
        C2 -->|Valid| D2[Service]
        D2 --> E2[Concurrency<br/>Check]
        E2 -->|Pass| F2[Business Rules]
        F2 -->|Pass| G2[Mapster<br/>Request → Entity]
        G2 -->|Entity| D2
        D2 --> H2[Stamp Audit<br/>Fields]
        H2 --> I2[Repository]
        I2 --> J2[UnitOfWork]
        J2 --> K2[DbContext<br/>+ Soft Delete<br/>Interceptor]
        K2 --> L2[Database<br/>INSERT/UPDATE]
        L2 -->|New State| K2
        K2 -->|Updated Entity| J2
        J2 -->|Entity| I2
        I2 -->|Entity| D2
        D2 --> M2[Mapster<br/>Entity → DTO<br/>New Token]
        M2 -->|Response| D2
        D2 -->|Response| B2
        B2 -->|JSON| A2
    end
    
    style A1 fill:#e3f2fd
    style A2 fill:#e3f2fd
    style B1 fill:#fff4e6
    style B2 fill:#fff4e6
    style C1 fill:#e8f5e9
    style C2 fill:#ffe0b2
    style D1 fill:#fce4ec
    style D2 fill:#e8f5e9
    style E1 fill:#fce4ec
    style E2 fill:#ffe0b2
    style F1 fill:#ffebee
    style F2 fill:#ffe0b2
    style G1 fill:#e8f5e9
    style G2 fill:#e8f5e9
```

---

## Summary

This document provides visual representations of:

✅ **Entity Relationships** - Database schema with detailed field explanations  
✅ **Class Hierarchies** - Domain model inheritance and interfaces  
✅ **Request/Response Patterns** - Application layer contracts  
✅ **Repository Pattern** - Infrastructure layer abstractions  
✅ **Sequence Flows** - Step-by-step operation flows with notes  
✅ **Architecture Layers** - Clean architecture visualization  
✅ **Processing Pipeline** - Request lifecycle from HTTP to database  
✅ **Dependency Injection** - Service container configuration  
✅ **Data Flows** - Read vs write operation differences  

All diagrams include single-line explanations for each property and method to clarify their purpose.

---

**Document Version**: 1.0  
**Last Updated**: November 16, 2025  
**Mermaid Version**: Compatible with Mermaid.js 10.0+

