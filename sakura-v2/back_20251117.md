# Sakura Backend - Complete Architecture Documentation

## Table of Contents
1. [System Overview](#system-overview)
2. [Architecture Pattern](#architecture-pattern)
3. [Project Structure](#project-structure)
4. [Domain Layer](#domain-layer)
5. [Infrastructure Layer](#infrastructure-layer)
6. [Application Layer](#application-layer)
7. [API Layer](#api-layer)
8. [Security & Authentication](#security--authentication)
9. [Data Flow](#data-flow)
10. [Database Schema](#database-schema)
11. [API Endpoints Reference](#api-endpoints-reference)

---

## 1. System Overview

**Sakura Backend** is a .NET 8 Web API designed to manage workspaces, applications, and security models for a multi-tenant data governance platform. It provides RESTful endpoints for workspace administration, security model configuration, and user authentication.

### Technology Stack
- **.NET 8**: Framework
- **ASP.NET Core Web API**: REST API hosting
- **Entity Framework Core**: ORM for SQL Server
- **SQL Server**: Database
- **Mapster**: Object-to-object mapping
- **FluentValidation**: Request validation
- **JWT**: Token-based authentication
- **Azure Key Vault**: Secrets management
- **Swagger/OpenAPI**: API documentation

### Key Features
- Clean Architecture with separation of concerns
- Optimistic concurrency control using HMAC-SHA256 tokens
- Soft delete pattern for data preservation
- Audit trail (CreatedBy, CreatedAt, UpdatedBy, UpdatedAt)
- Flexible authentication (Azure AD or local JWT)
- Repository and Unit of Work patterns
- Comprehensive validation pipeline

---

## 2. Architecture Pattern

The solution follows **Clean Architecture** principles with clear layer separation:

```
┌─────────────────────────────────────────────────────────────┐
│                      API Layer                               │
│  (Controllers, Middleware, Startup Configuration)           │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                  Application Layer                           │
│  (Services, DTOs, Requests, Responses, Validators)          │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                    Domain Layer                              │
│  (Entities, Interfaces, Business Rules, Enums)              │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                Infrastructure Layer                          │
│  (DbContext, Repositories, External Services)               │
└─────────────────────────────────────────────────────────────┘
```

### Dependency Flow
- API → Application → Domain ← Infrastructure
- Domain has no dependencies (pure business logic)
- Infrastructure depends on Domain (implements interfaces)
- Application depends on Domain (orchestrates business logic)
- API depends on Application (exposes services via HTTP)

---

## 3. Project Structure

```
Sakura_Backend/
├── Dentsu.SakuraApi/              # API Host Project
│   ├── Controllers/               # REST API Controllers
│   ├── Middleware/                # Custom middleware
│   ├── Configurations/            # Startup configuration modules
│   ├── ActionFilters/             # MVC action filters
│   └── Program.cs                 # Application entry point
│
├── Dentsu.Sakura.Application/     # Application Layer
│   ├── DTOs/                      # Data Transfer Objects
│   ├── Requests/                  # Request models (Commands)
│   ├── Responses/                 # Response models (Query results)
│   ├── Services/                  # Business logic orchestration
│   ├── Validators/                # FluentValidation validators
│   ├── Mapping/                   # Mapster configuration
│   └── Interfaces/                # Service abstractions
│
├── Dentsu.Sakura.Domain/          # Domain Layer
│   ├── Entities/                  # Domain models
│   │   ├── Base/                  # Base entity classes
│   │   ├── Workspaces/            # Workspace domain
│   │   ├── Security/              # Security domain
│   │   └── Common/                # Shared entities
│   ├── Interfaces/                # Domain interfaces
│   │   ├── Entities/              # Entity contracts
│   │   └── Repositories/          # Repository contracts
│   └── Enums.cs                   # Domain enumerations
│
├── Dentsu.Sakura.Infrastructure/  # Infrastructure Layer
│   ├── Data/                      # EF Core context
│   │   ├── SakuraDbContext.cs     # Database context
│   │   ├── SakuraRepository.cs    # Generic repository
│   │   └── UnitOfWork.cs          # Unit of Work pattern
│   └── Repositories/              # Specific repositories
│
├── Dentsu.Sakura.Shared/          # Shared Utilities
│   ├── Extensions/                # Extension methods
│   └── Requests/                  # Shared request models
│
└── tests/                         # Test Projects
    ├── Dentsu.Sakura.Application.UnitTests/
    └── Dentsu.Sakura.Testing/
```

---

## 4. Domain Layer

### 4.1 Base Entities

#### SakuraEntity<TKey>
**Purpose**: Provides base identity and equality comparison for all entities.

**Properties:**
- `Id` (TKey): Primary key (typically int)

**Features:**
- Implements `IEquatable<T>` for proper entity comparison
- Overrides `Equals`, `GetHashCode`, `==`, `!=` operators
- Ensures entities are compared by ID, not reference

#### SakuraAuditableEntity
**Purpose**: Extends SakuraEntity with audit trail fields.

**Properties:**
- `CreatedBy` (string): User who created the record
- `CreatedAt` (DateTime): Creation timestamp
- `UpdatedBy` (string): User who last updated
- `UpdatedAt` (DateTime): Last update timestamp

**Inherits:** `SakuraEntity<int>`

**Implements:** `IAuditable`

### 4.2 Core Entities

#### Workspace
**Purpose**: Represents a workspace - the top-level organizational unit for data governance.

**Properties:**
- `WorkspaceName` (string, required): Display name
- `WorkspaceCode` (string, required): Unique identifier code
- `WorkspaceOwner` (string, required): Business owner email
- `WorkspaceTechOwner` (string, required): Technical owner email
- `WorkspaceApprover` (string, required): Default approver email
- `WorkspaceEntraGroupUID` (string, nullable): Azure Entra Group ID
- `WorkspaceTag` (string, nullable): Tags for categorization
- `IsActive` (bool): Soft delete flag

**Relationships:**
- One-to-Many with `WorkspaceApp` (via `Apps` collection)

**Implements:** `ISoftDeletable`

#### WorkspaceApp
**Purpose**: Represents an application within a workspace (e.g., Power BI, Tableau).

**Properties:**
- `AppCode` (string, required): Unique app identifier
- `AppName` (string, required): Display name
- `AppOwner` (string, required): App business owner
- `AppTechnicalOwner` (string, required): App technical owner
- `AppEntraGroupUID` (string): Azure Entra Group ID
- `OLSMode` (enum): Object Level Security mode (Managed/Unmanaged)
- `ApprovalMode` (enum): Approval workflow (AppBased/AudienceBased)
- `Approvers` (string): Comma-separated approver emails (stored)
- `ApproversList` (IList<string>, NotMapped): Parsed list of approvers
- `AdditionalQuestionsJSON` (string): Custom questions in JSON
- `IsActive` (bool): Soft delete flag
- `WorkspaceId` (int): Foreign key to Workspace

**Relationships:**
- Many-to-One with `Workspace` (via `Workspace` navigation property)

**Helper Methods:**
- `AddApprover(string email)`: Adds approver to list
- `RemoveApprover(string email)`: Removes approver from list

**Implements:** `ISoftDeletable`

#### SecurityModel
**Purpose**: Defines Row-Level Security (RLS) configuration for a workspace.

**Properties:**
- `WorkspaceId` (int): Parent workspace
- `ModelCode` (string, required): Unique security model code
- `ModelName` (string, required): Display name
- `Description` (string, nullable): Model description
- `IsActive` (bool): Soft delete flag

**Relationships:**
- One-to-Many with `SecurityDimension` (via `SecurityDimensions` collection)
- One-to-Many with `SecurityModelTypeMapping` (via `SecurityTypeMappings` collection)

**Database Table:** `dbo.SecurityModels`

#### SecurityDimension
**Purpose**: Defines a dimension (e.g., Region, Department) within a security model.

**Properties:**
- `SecurityModelId` (int): Parent security model
- `DimensionCode` (string, required): Unique dimension code
- `DimensionName` (string, required): Display name
- `SourceTable` (string, nullable): Source table in database
- `DimensionType` (int): Type identifier
- `IsActive` (bool): Soft delete flag

**Relationships:**
- Many-to-One with `SecurityModel` (via `SecurityModel` navigation property)

**Database Table:** `dbo.SecurityDimensions`

#### SecurityModelTypeMapping
**Purpose**: Links security models to security types (from LoVs table).

**Properties:**
- `SecurityModelId` (int): Parent security model
- `SecurityTypeCode` (string, required): References LoVs.LoVValue where LoVType='SecurityType'

**Relationships:**
- Many-to-One with `SecurityModel`

**Database Table:** `dbo.SecurityModelTypeMappings`

#### LoVs (List of Values)
**Purpose**: Stores reference data (dropdowns, lookup values).

**Properties:**
- `LoVId` (int): Primary key
- `LovType` (string): Category (e.g., SecurityType, ApproverLevel)
- `LoVValue` (string): Code value
- `LoVName` (string): Display name
- `LoVDescription` (string): Description
- `ParentLoVType` (string): For hierarchical LoVs
- `ParentLoVValue` (string): Parent reference
- `CreatedAt` (DateTime): Creation timestamp
- `CreatedBy` (string): Creator
- `UpdatedAt` (DateTime): Last update
- `UpdatedBy` (string): Last updater

**Database Table:** `dbo.LoVs`

**Note:** Needs refactoring (see TODO in code - should inherit from SakuraAuditableEntity)

#### User
**Purpose**: Stores local user accounts for development/testing.

**Properties:**
- `Id` (string): User identifier (GUID)
- `UserName` (string): Username
- `PasswordHash` (byte[]): Hashed password
- `PasswordSalt` (byte[]): Password salt
- `IsActive` (bool): Active flag
- `Email` (string, nullable): User email
- `CreatedAt` (DateTime): Registration timestamp

**Note:** Used for local authentication only; production uses Azure AD.

#### RefreshToken
**Purpose**: Stores refresh tokens for JWT authentication.

**Properties:**
- `TokenId` (int): Primary key
- `Token` (string, required): Hashed refresh token
- `UserId` (string, required): User identifier
- `CreatedAt` (DateTime): Token creation
- `ExpiresAt` (DateTime): Token expiration
- `CreatedByIp` (string): Client IP address
- `Revoked` (bool): Revocation flag
- `RevokedAt` (DateTime, nullable): Revocation timestamp

**Database Table:** `dbo.RefreshToken`

### 4.3 Enumerations

#### OLSMode
**Purpose**: Defines Object Level Security mode for apps.

**Values:**
- `Managed = 0`: Security managed by Sakura
- `Unmanaged = 1`: Security managed externally

#### ApprovalMode
**Purpose**: Defines approval workflow type.

**Values:**
- `AppBased = 0`: Approval at application level
- `AudienceBased = 1`: Approval at audience level

### 4.4 Domain Interfaces

#### ISoftDeletable
**Purpose**: Marks entities supporting soft delete.

**Property:**
- `IsActive` (bool): Indicates if record is active

#### IAuditable
**Purpose**: Marks entities with audit trail.

**Properties:**
- `CreatedBy`, `CreatedAt`, `UpdatedBy`, `UpdatedAt`

#### IEntity<TKey>
**Purpose**: Marks entities with a primary key.

**Property:**
- `Id` (TKey): Primary key

---

## 5. Infrastructure Layer

### 5.1 SakuraDbContext

**Purpose**: EF Core database context managing all entity sets and configurations.

**DbSets:**
- `Workspaces`: Workspace entities
- `Lovs`: List of Values
- `RefreshTokens`: Refresh tokens
- `SecurityModels`: Security models
- `SecurityDimensions`: Security dimensions

**Key Configurations:**

1. **Soft Delete Global Filter**
   - Automatically filters out `IsActive = false` records
   - Applied using reflection to all entities implementing `ISoftDeletable`
   - Filter: `e => e.IsActive`

2. **Soft Delete Interceptor**
   - Overrides `SaveChanges` methods
   - Intercepts `EntityState.Deleted` operations
   - Converts hard deletes to soft deletes by setting `IsActive = false`

3. **Entity Configurations**
   - RefreshToken: Indexed on Token and UserId
   - SecurityModel: Indexed on WorkspaceId, ModelCode, IsActive
   - SecurityDimension: Cascade delete with SecurityModel

**Methods:**
- `ApplySoftDeleteRules()`: Converts deletes to updates

### 5.2 SakuraRepository<TEntity, TKey>

**Purpose**: Generic repository implementing CRUD operations.

**Key Methods:**
- `GetByIdAsync(TKey id)`: Retrieve by primary key
- `GetAllAsync()`: Get all active entities
- `GetPagedAsync(int pageNumber, int pageSize)`: Paginated retrieval
- `AddAsync(TEntity entity)`: Add new entity
- `Update(TEntity entity)`: Update existing
- `Delete(TKey id)`: Soft delete by ID
- `ExistsAsync(Expression<Func<TEntity, bool>> predicate)`: Check existence
- `FindAsync(Expression<Func<TEntity, bool>> predicate)`: Query with predicate
- `Include(params Expression<Func<TEntity, object>>[] includes)`: Eager loading

**Features:**
- Respects soft delete filters
- Supports eager loading
- Provides raw SQL projection

### 5.3 UnitOfWork

**Purpose**: Manages transaction boundaries and repository caching.

**Properties:**
- `Repositories`: Dictionary cache of typed repositories

**Methods:**
- `Repository<TEntity, TKey>()`: Get or create repository
- `SaveChangesAsync()`: Commit transaction
- `SaveChanges()`: Synchronous commit
- `Dispose()`: Release context

**Pattern Benefits:**
- Single transaction across multiple repositories
- Repository instance reuse within a request
- Automatic transaction rollback on errors

---

## 6. Application Layer

### 6.1 Request/Response Pattern

#### Base Request Classes

**SakuraRequest**
- Purpose: Base for all write operations
- Contains: `ConcurrencyToken` (string, required)

**SakuraCreateRequest** (extends SakuraRequest)
- Purpose: Base for create operations
- Additional: `CreatedBy` (string, required)

**SakuraUpdateRequest** (extends SakuraRequest)
- Purpose: Base for update operations
- Additional: `Id` (int, required), `UpdatedBy` (string, required)

**SakuraDeleteRequest** (extends SakuraRequest)
- Purpose: Base for delete operations
- Additional: `Id` (int, required), `DeletedBy` (string, required)

#### Base Response Classes

**SakuraResponse**
- Purpose: Base for all responses
- Contains: `ConcurrencyToken` (string) - auto-computed by Mapster

**ApiBaseResult**
- Purpose: Base API response envelope
- Properties: `Success` (bool), `Message` (string), `Errors` (List<ErrorInfo>)

**ApiSingleResult<T>** (implements IApiSingleResult<T>)
- Purpose: Single entity response
- Properties: `Data` (T)

**ApiListResult<T>** (implements IApiListResult<T>)
- Purpose: List response
- Properties: `Data` (List<T>), `Count` (int)

**ApiPagedListResult<T>** (implements IApiPagedListResult<T>)
- Purpose: Paginated response
- Properties: `Data`, `PageNumber`, `PageSize`, `TotalCount`, `TotalPages`

**ApiScalarResult<T>** (implements IApiScalarResult<T>)
- Purpose: Scalar value response (e.g., bool, int)
- Properties: `Value` (T)

### 6.2 Concrete Requests

#### CreateWorkspaceRequest
**Purpose**: Create new workspace
**Properties:**
- `WorkspaceName` (string, required)
- `WorkspaceCode` (string, required)
- `WorkspaceOwner` (string, required)
- `WorkspaceTechOwner` (string, required)
- `WorkspaceApprover` (string, required)
- `WorkspaceEntraGroupUID` (string, optional)
- `WorkspaceTag` (string, optional)

#### UpdateWorkspaceRequest
**Purpose**: Update existing workspace
**Properties:**
- Inherits all from CreateWorkspaceRequest
- Plus: `Id` (int), `UpdatedBy` (string)

#### DeleteWorkspaceRequest
**Purpose**: Soft delete workspace
**Properties:**
- `Id` (int, required)
- `DeletedBy` (string, required)
- `ConcurrencyToken` (string, required)

#### CreateSecurityModelRequest
**Purpose**: Create or update security model
**Properties:**
- `WorkspaceId` (int)
- `ModelCode` (string)
- `ModelName` (string)
- `Description` (string, optional)
- `SecurityTypes` (List<string>): Security type codes
- `Dimensions` (List<SecurityDimensionRequest>): Child dimensions
- `CreatedBy` (string)

#### SecurityDimensionRequest
**Properties:**
- `DimensionCode` (string)
- `DimensionName` (string)
- `SourceTable` (string, optional)
- `DimensionType` (int)

### 6.3 Concrete Responses

#### WorkspaceResponse
**Properties:**
- `Id` (int)
- `WorkspaceName`, `WorkspaceCode`, `WorkspaceOwner`, `WorkspaceTechOwner`, `WorkspaceApprover`
- `WorkspaceEntraGroupUID`, `WorkspaceTag`
- `IsActive` (bool)
- `CreatedAt`, `CreatedBy`, `UpdatedAt`, `UpdatedBy`
- `ConcurrencyToken` (inherited)

#### SecurityModelResponse
**Properties:**
- `Id`, `WorkspaceId`, `ModelCode`, `ModelName`, `Description`
- `SecurityTypes` (List<string>)
- `Dimensions` (List<SecurityDimensionResponse>)
- `IsActive`
- `CreatedAt`, `CreatedBy`, `ModifiedAt`, `ModifiedBy`
- `ConcurrencyToken`

#### SecurityModelSummaryResponse
**Properties:**
- `Id`, `ModelCode`, `ModelName`
- `SecurityTypes` (List<string>)
- `DimensionCount` (int)
- `IsActive`

#### SecurityDimensionResponse
**Properties:**
- `Id`, `DimensionCode`, `DimensionName`, `SourceTable`, `DimensionType`, `IsActive`

### 6.4 Application Services

#### IWorkspaceService & WorkspaceService

**Purpose**: Orchestrates workspace CRUD operations.

**Methods:**
1. `GetWorkspacesAsync()` → `List<WorkspaceResponse>`
   - Retrieves all active workspaces
   - Uses Mapster ProjectToType for efficient projection

2. `GetWorkspaceAsync(int id)` → `IApiSingleResult<WorkspaceResponse>`
   - Retrieves single workspace by ID
   - Returns 404 if not found

3. `AddWorkspaceAsync(CreateWorkspaceRequest)` → `IApiSingleResult<WorkspaceResponse>`
   - Validates uniqueness of WorkspaceCode
   - Stamps audit fields (CreatedBy, CreatedAt)
   - Returns created entity with concurrency token

4. `UpdateWorkspaceAsync(UpdateWorkspaceRequest)` → `IApiSingleResult<WorkspaceResponse>`
   - Validates concurrency token
   - Checks WorkspaceCode uniqueness (excluding current)
   - Updates allowed fields only
   - Stamps UpdatedBy, UpdatedAt

5. `DeleteWorkspaceAsync(DeleteWorkspaceRequest)` → `IApiScalarResult<bool>`
   - Validates concurrency token
   - Prevents double-deletion
   - Soft deletes via IsActive flag

**Business Rules:**
- WorkspaceCode must be unique across active records
- WorkspaceCode allows alphanumeric and underscore only
- Optimistic concurrency enforced on all writes

#### ISecurityModelService & SecurityModelService

**Purpose**: Manages security model lifecycle.

**Methods:**
1. `GetAllSecurityModelsAsync(int? workspaceId)` → `List<SecurityModelSummaryResponse>`
   - Lists all models with dimension counts
   - Optionally filters by workspace

2. `GetSecurityModelByIdAsync(int id)` → `SecurityModelResponse`
   - Returns full model with dimensions
   - Eager loads SecurityDimensions and SecurityTypeMappings

3. `GetSecurityModelByCodeAsync(string code)` → `SecurityModelResponse`
   - Retrieves by ModelCode (case-insensitive)

4. `CreateSecurityModelAsync(CreateSecurityModelRequest)` → `SecurityModelResponse`
   - Converts ModelCode to uppercase
   - Creates child dimensions
   - Creates security type mappings

5. `UpdateSecurityModelAsync(int id, CreateSecurityModelRequest)` → `SecurityModelResponse`
   - Updates model properties
   - Replaces dimensions and mappings
   - Maintains audit trail

6. `GetSecurityTypesAsync(int workspaceId)` → `List<string>`
   - Returns security types linked to workspace models

**Business Rules:**
- ModelCode must be uppercase
- Dimensions cascade soft-delete with model
- SecurityTypeCode must exist in LoVs table

#### ITokenService & TokenService

**Purpose**: Manages JWT and refresh tokens.

**Methods:**
1. `GenerateAccessToken(string userId)` → `string`
   - Creates JWT with standard claims
   - Expiration: 8 hours
   - Includes userId, role claims

2. `GenerateAccessTokenWithUserInfo(...)` → `string`
   - Enriched JWT with user profile
   - Claims: userId, email, name, role, workspaceId, workspaceName, approverLevel

3. `GenerateRefreshTokenRaw()` → `string`
   - Creates cryptographically random token
   - 64-byte base64 string

4. `ComputeHash(string token)` → `string`
   - SHA256 hash of token
   - Stored in database for security

5. `SaveRefreshTokenAsync(...)` → `Task`
   - Persists hashed refresh token
   - Sets expiration (7 days default)

6. `RevokeRefreshTokenAsync(string hash)` → `Task`
   - Marks token as revoked
   - Sets RevokedAt timestamp

7. `GetRefreshTokenByHashAsync(string hash)` → `RefreshToken`
   - Retrieves token by hash
   - Used for refresh flow

#### IManageLoVService & ManageLoVService

**Purpose**: Manages List of Values (reference data).

**Methods:**
1. `GetLovTypesAsync()` → `List<string>`
   - Returns distinct LoV types

2. `GetLovsByTypeAsync(string lovType)` → `List<ManageLoVDto>`
   - Retrieves all LoVs of a type

3. `AddLovAsync(ManageLoVDto)` → `bool`
   - Adds new LoV entry

4. `UpdateLovAsync(int LoVId, ManageLoVDto)` → `bool`
   - Updates existing LoV

5. `DeleteLovAsync(int LoVId)` → `bool`
   - Deletes LoV (hard delete - no soft delete implemented)

### 6.5 Validation

#### WorkspaceRequestValidator

**Purpose**: Validates CreateWorkspaceRequest and UpdateWorkspaceRequest.

**Rules:**
1. `WorkspaceName`: Required, max 255 characters
2. `WorkspaceCode`: Required, max 50 characters, alphanumeric + underscore only
3. `WorkspaceOwner`: Required, valid email
4. `WorkspaceTechOwner`: Required, valid email
5. `WorkspaceApprover`: Required, valid email
6. `WorkspaceEntraGroupUID`: Optional, GUID format if provided

**Custom Extension:**
- `MustHaveAllFilled()`: Ensures all required fields are non-empty

### 6.6 Object Mapping (Mapster)

#### MapsterConfig

**Purpose**: Configures Mapster mappings.

**Global Mappings:**
1. `SakuraAuditableEntity` → `SakuraResponse`
   - Auto-compute ConcurrencyToken from Id and UpdatedAt

2. `Workspace` ↔ `WorkspaceResponse`
   - Bidirectional mapping
   - Ignores server-owned fields (CreatedAt, UpdatedAt, ConcurrencyToken)

3. `CreateWorkspaceRequest` → `Workspace`
   - Ignores audit fields (set by service)

4. `UpdateWorkspaceRequest` → `Workspace`
   - Ignores audit fields

**Token Computation:**
- Uses `ConcurrencyTokenExtensions.ComputeToken(entity)`
- HMAC-SHA256 of `{Id}:{UpdatedAtTicks}`

---

## 7. API Layer

### 7.1 Controllers

#### WorkspaceController

**Base Route:** `/api/workspace`

**Endpoints:**

| Method | Route | Description | Request | Response |
|--------|-------|-------------|---------|----------|
| GET | `/` | List all workspaces | - | `ApiListResult<WorkspaceResponse>` |
| GET | `/{id}` | Get by ID | id (route) | `ApiSingleResult<WorkspaceResponse>` |
| POST | `/` | Create workspace | `CreateWorkspaceRequest` | `ApiSingleResult<WorkspaceResponse>` |
| PUT | `/` | Update workspace | `UpdateWorkspaceRequest` | `ApiSingleResult<WorkspaceResponse>` |
| PUT | `/delete` | Soft delete | `DeleteWorkspaceRequest` | `ApiScalarResult<bool>` |

**Response Format:**
```json
{
  "success": true,
  "data": { ... }
}
```

#### SecurityController

**Base Route:** `/api/security`

**Endpoints:**

| Method | Route | Description | Request | Response |
|--------|-------|-------------|---------|----------|
| GET | `/` | List models | `workspaceId` (query, optional) | `List<SecurityModelSummaryResponse>` |
| GET | `/{id}` | Get by ID | id (route) | `SecurityModelResponse` |
| GET | `/code/{code}` | Get by code | code (route) | `SecurityModelResponse` |
| POST | `/` | Create model | `CreateSecurityModelRequest` | `SecurityModelResponse` |
| PUT | `/{id}` | Update model | id (route), `CreateSecurityModelRequest` | `SecurityModelResponse` |
| GET | `/workspaces/{workspaceId}/security-types` | Get security types | workspaceId (route) | `List<string>` |

**Response Format:**
```json
{
  "success": true,
  "message": "...",
  "data": { ... }
}
```

#### AuthController

**Base Route:** `/api/auth`

**Endpoints:**

| Method | Route | Description | Request | Response |
|--------|-------|-------------|---------|----------|
| POST | `/login` | User login | `LoginRequestDTO` | Token + user info |
| POST | `/refresh` | Refresh token | Cookie: refreshToken | New access token |
| POST | `/logout` | User logout | Cookie: refreshToken | Success message |

**Login Request:**
```json
{
  "email": "user@example.com",
  "password": "password",
  "azureToken": "..." // Optional, for Azure AD
}
```

**Login Response (Dev Mode):**
```json
{
  "token": "eyJhbGc...",
  "userId": "1",
  "email": "user@example.com",
  "name": "John Doe",
  "role": "Admin",
  "workspaceId": 1,
  "workspaceName": "Workspace1",
  "approverLevel": "L1",
  "expiresAt": "2025-11-16T18:00:00Z"
}
```

**Authentication Modes:**
1. **Development** (`EnableAzureAuth = false`):
   - Email + password
   - Validates against temp-users.json
   - Issues local JWT

2. **Production** (`EnableAzureAuth = true`):
   - Azure AD token validation
   - Extracts user from Azure token
   - Issues server-managed refresh token

#### AdminController

**Base Route:** `/api/admin`

**Endpoints:**

| Method | Route | Description | Request | Response |
|--------|-------|-------------|---------|----------|
| GET | `/types` | Get LoV types | - | `List<string>` |
| GET | `/grid/{lovType}` | Get LoVs by type | lovType (route) | `List<ManageLoVDto>` |
| POST | `/` | Add LoV | `ManageLoVDto` | Success message |
| PUT | `/` | Update LoV | `LoVId` (query), `ManageLoVDto` | Success message |
| DELETE | `/{LoVId}` | Delete LoV | LoVId (route) | Success message |

### 7.2 Middleware

#### SakuraStandardMiddleware

**Purpose**: Adds standard headers to all responses.

**Headers:**
- `X-Sakura-Version`: Application version
- `X-Sakura-Release`: Build/release number

#### SakuraGlobalExceptionHandlerMiddleware

**Purpose**: Centralized exception handling.

**Behavior:**
- Catches all unhandled exceptions
- Maps exception types to HTTP status codes
- Returns consistent error response format

**Exception Mapping:**
- `ValidationException` → 400 Bad Request
- `NotFoundException` → 404 Not Found
- `UnauthorizedException` → 401 Unauthorized
- `ForbiddenException` → 403 Forbidden
- `All others` → 500 Internal Server Error

**Error Response Format:**
```json
{
  "success": false,
  "message": "Error summary",
  "errors": [
    {
      "field": "WorkspaceCode",
      "message": "Already exists",
      "errorCode": "DUPLICATE_CODE"
    }
  ],
  "traceId": "00-abc123...",
  "timestamp": "2025-11-16T10:00:00Z"
}
```

### 7.3 Startup Configuration

#### Program.cs

**Startup Sequence:**
1. Create WebApplicationBuilder
2. Configure Controllers with FluentValidation
3. Configure Swagger/OpenAPI
4. Load Azure Key Vault secrets
5. Configure SQL Server DbContext with connection from Key Vault
6. Configure access control (JWT or Azure AD)
7. Register services (IoC configuration)
8. Configure CORS for Angular dev server
9. Build application
10. Initialize concurrency secret
11. Configure middleware pipeline
12. Map controllers
13. Run application

**Configuration Modules:**
- `ConfigureControllers()`: MVC + JSON options
- `ConfigureSwagger()`: Swagger UI + OpenAPI docs
- `ConfigureKeyVault()`: Azure Key Vault integration
- `ConfigureAccessControl()`: Authentication/authorization
- `ConfigureIoC()`: Dependency injection
- `ConfigureFluentValidation()`: Validation pipeline
- `ConfigureCORS()`: Cross-origin policy
- `ConfigureMiddleware()`: Middleware registration

### 7.4 Action Filters

#### ValidateActionParametersAttribute

**Purpose**: Validates route/query parameters before action execution.

**Usage:**
```csharp
[HttpGet("{id}")]
[ValidateActionParameters]
public async Task<IActionResult> Get([FromRoute][Required] int id)
```

**Behavior:**
- Checks `ModelState.IsValid`
- Returns 400 with validation errors if invalid
- Allows action to proceed if valid

---

## 8. Security & Authentication

### 8.1 Authentication Strategies

#### Local JWT (Development)

**Configuration:**
```json
{
  "AppSettings": {
    "EnableAzureAuth": false
  },
  "Jwt": {
    "Secret": "...",
    "Issuer": "SakuraAPI",
    "Audience": "SakuraClient",
    "ExpiryHours": 8
  }
}
```

**Flow:**
1. User sends email + password to `/api/auth/login`
2. Server validates against temp-users.json
3. Server generates JWT with claims
4. Server creates refresh token, stores hash in database
5. Server returns JWT and sets HttpOnly refresh token cookie
6. Client includes JWT in `Authorization: Bearer {token}` header

**JWT Claims:**
- `sub`: User ID
- `email`: User email
- `name`: User name
- `role`: User role
- `workspaceId`: User's workspace
- `workspaceName`: Workspace name
- `approverLevel`: Approver level

#### Azure AD (Production)

**Configuration:**
```json
{
  "AppSettings": {
    "EnableAzureAuth": true
  },
  "AzureAd": {
    "Instance": "https://login.microsoftonline.com/",
    "TenantId": "...",
    "ClientId": "...",
    "Audience": "..."
  }
}
```

**Flow:**
1. User authenticates with Azure AD (frontend)
2. User receives Azure access token
3. User sends Azure token to `/api/auth/login`
4. Server validates Azure token
5. Server extracts user claims from Azure token
6. Server issues server-managed refresh token
7. Client uses Azure token for API calls

**Validation:**
- Validates signature using Azure AD signing keys
- Validates issuer, audience, expiration
- Zero clock skew tolerance

### 8.2 Optimistic Concurrency Control

**Purpose**: Prevent lost updates when multiple users edit the same entity.

**Mechanism:**
1. **Token Generation**
   - Computed as HMAC-SHA256 of `{Id}:{UpdatedAtTicks}`
   - Secret key stored in Azure Key Vault
   - Included in all responses via `ConcurrencyToken` field

2. **Token Validation**
   - Client must send token with update/delete requests
   - Server recomputes token from current entity state
   - Comparison: `request.ConcurrencyToken == computed`
   - Mismatch → `ValidationException` with 400 status

3. **Error Response**
   ```json
   {
     "success": false,
     "errors": [
       {
         "field": "ConcurrencyToken",
         "message": "Record was modified by another user. Last updated by: john@example.com at 2025-11-16 10:30 UTC",
         "errorCode": "CONCURRENCY_CONFLICT"
       }
     ]
   }
   ```

**Implementation:**
- Extension method: `ConcurrencyTokenExtensions.CheckConcurrency(request, entity)`
- Automatic computation via Mapster: `AfterMapping((src, dest) => dest.ConcurrencyToken = ComputeToken(src))`

### 8.3 Soft Delete

**Purpose**: Preserve data integrity and enable data recovery.

**Implementation:**
1. **Domain Interface**
   - Entities implement `ISoftDeletable` with `IsActive` property

2. **Query Filter**
   - EF Core global filter: `e => e.IsActive`
   - Automatically applied to all queries
   - Hides inactive records

3. **Delete Interceptor**
   - Overrides `DbContext.SaveChanges()`
   - Detects `EntityState.Deleted` operations
   - Sets `IsActive = false` instead of deleting
   - Changes state to `EntityState.Modified`

4. **Service Logic**
   - Delete methods stamp `UpdatedBy` with `DeletedBy` value
   - Set `UpdatedAt` to current time
   - Call `repository.Delete(id)` which triggers soft delete

**Affected Entities:**
- Workspace
- WorkspaceApp
- SecurityModel
- SecurityDimension

### 8.4 CORS Configuration

**Purpose**: Allow frontend (Angular) to call API during development.

**Configuration:**
```csharp
services.AddCors(options =>
{
    options.AddDefaultPolicy(builder =>
    {
        builder.WithOrigins("http://localhost:4200")
               .AllowAnyHeader()
               .AllowAnyMethod()
               .AllowCredentials(); // For refresh token cookies
    });
});
```

**Production:**
- Configure specific frontend domain
- Use HTTPS only
- Validate origin against whitelist

---

## 9. Data Flow

### 9.1 Read Flow (GET Request)

```
┌────────────┐      ┌────────────┐      ┌─────────────┐      ┌──────────┐
│   Client   │─────▶│ Controller │─────▶│   Service   │─────▶│   Repo   │
└────────────┘      └────────────┘      └─────────────┘      └──────────┘
                                                                    │
                                                                    ▼
                                                              ┌──────────┐
                                                              │ DbContext│
                                                              └──────────┘
                                                                    │
                                                                    ▼
                                                              ┌──────────┐
                                                              │ Database │
                                                              └──────────┘
                                                                    │
┌────────────┐      ┌────────────┐      ┌─────────────┐      ┌──────────┐
│   Client   │◀─────│ Controller │◀─────│   Service   │◀─────│  Mapster │
└────────────┘      └────────────┘      └─────────────┘      └──────────┘
  (JSON)           (Response DTO)      (Response DTO)       (Entity→DTO)
```

**Steps:**
1. Client sends GET request
2. Controller receives request
3. Controller calls service method
4. Service calls repository query
5. Repository queries DbContext
6. DbContext applies query filter (soft delete)
7. DbContext executes SQL query
8. Database returns rows
9. Mapster maps Entity → Response DTO
10. Mapster computes ConcurrencyToken
11. Service returns Response DTO
12. Controller wraps in ApiResult
13. Client receives JSON

### 9.2 Write Flow (POST/PUT Request)

```
┌────────────┐      ┌────────────┐      ┌─────────────┐
│   Client   │─────▶│ Controller │─────▶│ Validator   │
└────────────┘      └────────────┘      └─────────────┘
  (Request)           │                        │
                      │                        │ (Valid?)
                      │                        ▼
                      │                  ┌─────────────┐
                      └─────────────────▶│   Service   │
                                         └─────────────┘
                                               │
                      ┌────────────────────────┼────────────────────┐
                      ▼                        ▼                    ▼
              ┌──────────────┐       ┌──────────────┐     ┌──────────────┐
              │ Concurrency  │       │   Business   │     │   Mapster    │
              │    Check     │       │     Rules    │     │ (Req→Entity) │
              └──────────────┘       └──────────────┘     └──────────────┘
                      │                        │                    │
                      └────────────────────────┼────────────────────┘
                                               ▼
                                         ┌─────────────┐
                                         │    Repo     │
                                         └─────────────┘
                                               │
                                               ▼
                                         ┌─────────────┐
                                         │ UnitOfWork  │
                                         └─────────────┘
                                               │
                                               ▼
                                         ┌─────────────┐
                                         │  DbContext  │
                                         └─────────────┘
                                               │
                                               ▼
                                         ┌─────────────┐
                                         │  Database   │
                                         └─────────────┘
                                               │
┌────────────┐      ┌────────────┐      ┌─────────────┐
│   Client   │◀─────│ Controller │◀─────│   Service   │
└────────────┘      └────────────┘      └─────────────┘
  (Response)        (ApiResult)        (Response DTO)
```

**Steps:**
1. Client sends POST/PUT request with JSON
2. FluentValidation validates request model
3. If invalid → 400 with validation errors
4. Controller calls service method
5. Service checks concurrency token (if update/delete)
6. If token mismatch → 400 with concurrency error
7. Service validates business rules (e.g., uniqueness)
8. If rule violation → 400 with error
9. Mapster maps Request DTO → Entity
10. Service stamps audit fields (CreatedBy, UpdatedBy, etc.)
11. Service calls repository method
12. Repository adds/updates entity in DbContext
13. UnitOfWork calls SaveChangesAsync()
14. DbContext applies soft delete rules
15. DbContext saves to database
16. Entity updated with new UpdatedAt
17. Mapster maps Entity → Response DTO
18. Mapster computes new ConcurrencyToken
19. Service returns Response DTO
20. Controller wraps in ApiResult
21. Client receives JSON with new token

### 9.3 Delete Flow (PUT /delete)

```
┌────────────┐      ┌────────────┐      ┌─────────────┐
│   Client   │─────▶│ Controller │─────▶│   Service   │
└────────────┘      └────────────┘      └─────────────┘
  (DeleteReq)                                  │
   + Token                                     ▼
                                         ┌─────────────┐
                                         │ Concurrency │
                                         │    Check    │
                                         └─────────────┘
                                               │
                                               ▼
                                         ┌─────────────┐
                                         │Set IsActive │
                                         │   = false   │
                                         └─────────────┘
                                               │
                                               ▼
                                         ┌─────────────┐
                                         │ Stamp Audit │
                                         │   Fields    │
                                         └─────────────┘
                                               │
                                               ▼
                                         ┌─────────────┐
                                         │  DbContext  │
                                         │ SaveChanges │
                                         └─────────────┘
                                               │
                                               ▼
                                         ┌─────────────┐
                                         │  Database   │
                                         │   UPDATE    │
                                         └─────────────┘
```

**Steps:**
1. Client sends DELETE request with ID + ConcurrencyToken
2. Service retrieves entity
3. Service checks concurrency token
4. Service sets `IsActive = false`
5. Service sets `UpdatedBy = DeletedBy`, `UpdatedAt = Now`
6. DbContext saves changes
7. Database record updated (not deleted)
8. Service returns success
9. Client receives confirmation

---

## 10. Database Schema

### 10.1 Tables

#### dbo.Workspaces
```sql
CREATE TABLE dbo.Workspaces (
    Id INT PRIMARY KEY IDENTITY(1,1),
    WorkspaceName NVARCHAR(255) NOT NULL,
    WorkspaceCode NVARCHAR(50) NOT NULL,
    WorkspaceOwner NVARCHAR(450) NOT NULL,
    WorkspaceTechOwner NVARCHAR(450) NOT NULL,
    WorkspaceApprover NVARCHAR(450) NOT NULL,
    WorkspaceEntraGroupUID NVARCHAR(450) NULL,
    WorkspaceTag NVARCHAR(255) NULL,
    IsActive BIT NOT NULL DEFAULT 1,
    CreatedBy NVARCHAR(450) NOT NULL,
    CreatedAt DATETIME2 NOT NULL,
    UpdatedBy NVARCHAR(450) NOT NULL,
    UpdatedAt DATETIME2 NOT NULL
);
CREATE INDEX IX_Workspaces_WorkspaceCode ON dbo.Workspaces(WorkspaceCode);
CREATE INDEX IX_Workspaces_IsActive ON dbo.Workspaces(IsActive);
```

#### dbo.WorkspaceApps (Not yet created - inferred from entity)
```sql
CREATE TABLE dbo.WorkspaceApps (
    Id INT PRIMARY KEY IDENTITY(1,1),
    WorkspaceId INT NOT NULL,
    AppCode NVARCHAR(50) NOT NULL,
    AppName NVARCHAR(255) NOT NULL,
    AppOwner NVARCHAR(450) NOT NULL,
    AppTechnicalOwner NVARCHAR(450) NOT NULL,
    AppEntraGroupUID NVARCHAR(450) NULL,
    OLSMode INT NOT NULL,
    ApprovalMode INT NOT NULL,
    Approvers NVARCHAR(MAX) NULL,
    AdditionalQuestionsJSON NVARCHAR(MAX) NULL,
    IsActive BIT NOT NULL DEFAULT 1,
    CreatedBy NVARCHAR(450) NOT NULL,
    CreatedAt DATETIME2 NOT NULL,
    UpdatedBy NVARCHAR(450) NOT NULL,
    UpdatedAt DATETIME2 NOT NULL,
    CONSTRAINT FK_WorkspaceApps_Workspaces FOREIGN KEY (WorkspaceId) 
        REFERENCES dbo.Workspaces(Id)
);
```

#### dbo.SecurityModels
```sql
CREATE TABLE dbo.SecurityModels (
    Id INT PRIMARY KEY IDENTITY(1,1),
    WorkspaceId INT NOT NULL,
    ModelCode NVARCHAR(50) NOT NULL,
    ModelName NVARCHAR(255) NOT NULL,
    Description NVARCHAR(1000) NULL,
    IsActive BIT NOT NULL DEFAULT 1,
    CreatedBy NVARCHAR(450) NOT NULL,
    CreatedAt DATETIME2 NOT NULL,
    UpdatedBy NVARCHAR(450) NOT NULL,
    UpdatedAt DATETIME2 NOT NULL
);
CREATE INDEX IX_SecurityModels_WorkspaceId ON dbo.SecurityModels(WorkspaceId);
CREATE INDEX IX_SecurityModels_ModelCode ON dbo.SecurityModels(ModelCode);
CREATE INDEX IX_SecurityModels_IsActive ON dbo.SecurityModels(IsActive);
```

#### dbo.SecurityDimensions
```sql
CREATE TABLE dbo.SecurityDimensions (
    Id INT PRIMARY KEY IDENTITY(1,1),
    SecurityModelId INT NOT NULL,
    DimensionCode NVARCHAR(50) NOT NULL,
    DimensionName NVARCHAR(255) NOT NULL,
    SourceTable NVARCHAR(255) NULL,
    DimensionType INT NOT NULL,
    IsActive BIT NOT NULL DEFAULT 1,
    CreatedBy NVARCHAR(450) NOT NULL,
    CreatedAt DATETIME2 NOT NULL,
    UpdatedBy NVARCHAR(450) NOT NULL,
    UpdatedAt DATETIME2 NOT NULL,
    CONSTRAINT FK_SecurityDimensions_SecurityModels FOREIGN KEY (SecurityModelId)
        REFERENCES dbo.SecurityModels(Id) ON DELETE CASCADE
);
CREATE INDEX IX_SecurityDimensions_SecurityModelId ON dbo.SecurityDimensions(SecurityModelId);
CREATE INDEX IX_SecurityDimensions_DimensionCode ON dbo.SecurityDimensions(DimensionCode);
CREATE INDEX IX_SecurityDimensions_IsActive ON dbo.SecurityDimensions(IsActive);
```

#### dbo.SecurityModelTypeMappings
```sql
CREATE TABLE dbo.SecurityModelTypeMappings (
    Id INT PRIMARY KEY IDENTITY(1,1),
    SecurityModelId INT NOT NULL,
    SecurityTypeCode NVARCHAR(50) NOT NULL,
    CreatedBy NVARCHAR(450) NOT NULL,
    CreatedAt DATETIME2 NOT NULL,
    UpdatedBy NVARCHAR(450) NOT NULL,
    UpdatedAt DATETIME2 NOT NULL,
    CONSTRAINT FK_SecurityModelTypeMappings_SecurityModels FOREIGN KEY (SecurityModelId)
        REFERENCES dbo.SecurityModels(Id) ON DELETE CASCADE
);
CREATE INDEX IX_SecurityModelTypeMappings_SecurityModelId ON dbo.SecurityModelTypeMappings(SecurityModelId);
```

#### dbo.LoVs
```sql
CREATE TABLE dbo.LoVs (
    Id INT PRIMARY KEY IDENTITY(1,1),
    LovType NVARCHAR(100) NULL,
    LoVValue NVARCHAR(100) NULL,
    LoVName NVARCHAR(255) NULL,
    LoVDescription NVARCHAR(500) NULL,
    ParentLoVType NVARCHAR(100) NULL,
    ParentLoVValue NVARCHAR(100) NULL,
    CreatedAt DATETIME2 NOT NULL,
    CreatedBy NVARCHAR(450) NULL,
    UpdatedAt DATETIME2 NOT NULL,
    UpdatedBy NVARCHAR(450) NULL
);
CREATE INDEX IX_LoVs_LovType ON dbo.LoVs(LovType);
```

#### dbo.RefreshToken
```sql
CREATE TABLE dbo.RefreshToken (
    TokenId INT PRIMARY KEY IDENTITY(1,1),
    Token NVARCHAR(450) NOT NULL,
    UserId NVARCHAR(450) NOT NULL,
    CreatedAt DATETIME2 NOT NULL,
    ExpiresAt DATETIME2 NOT NULL,
    CreatedByIp NVARCHAR(45) NULL,
    Revoked BIT NOT NULL DEFAULT 0,
    RevokedAt DATETIME2 NULL
);
CREATE INDEX IX_RefreshToken_Token ON dbo.RefreshToken(Token);
CREATE INDEX IX_RefreshToken_UserId ON dbo.RefreshToken(UserId);
```

### 10.2 Relationships

```
Workspaces (1) ─────▶ (N) WorkspaceApps
                            
SecurityModels (1) ──▶ (N) SecurityDimensions
                 │
                 └───▶ (N) SecurityModelTypeMappings ──▶ LoVs (LoVType='SecurityType')
```

---

## 11. API Endpoints Reference

### Base URL
- Development: `https://localhost:5001/api`
- Production: `https://your-domain.com/api`

### Authentication
Most endpoints require JWT token:
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### Endpoints Summary

#### Workspace Management
```
GET    /api/workspace              - List all workspaces
GET    /api/workspace/{id}         - Get workspace by ID
POST   /api/workspace              - Create workspace
PUT    /api/workspace              - Update workspace
PUT    /api/workspace/delete       - Soft delete workspace
```

#### Security Model Management
```
GET    /api/security                              - List all security models
GET    /api/security?workspaceId={id}             - List models by workspace
GET    /api/security/{id}                         - Get model by ID
GET    /api/security/code/{code}                  - Get model by code
POST   /api/security                              - Create security model
PUT    /api/security/{id}                         - Update security model
GET    /api/security/workspaces/{id}/security-types - Get security types
```

#### Authentication
```
POST   /api/auth/login             - User login
POST   /api/auth/refresh           - Refresh access token
POST   /api/auth/logout            - User logout
```

#### Admin (LoV Management)
```
GET    /api/admin/types            - Get all LoV types
GET    /api/admin/grid/{lovType}   - Get LoVs by type
POST   /api/admin                  - Add new LoV
PUT    /api/admin                  - Update LoV
DELETE /api/admin/{LoVId}          - Delete LoV
```

---

## Summary

This Sakura Backend is a robust, enterprise-grade .NET 8 Web API implementing:

✅ **Clean Architecture** with clear separation of concerns  
✅ **Domain-Driven Design** with rich domain models  
✅ **Repository + Unit of Work** patterns for data access  
✅ **Optimistic Concurrency** using HMAC tokens  
✅ **Soft Delete** pattern for data preservation  
✅ **Comprehensive Audit Trail** (who, when)  
✅ **FluentValidation** for request validation  
✅ **Mapster** for efficient object mapping  
✅ **JWT Authentication** with refresh tokens  
✅ **Azure Key Vault** integration for secrets  
✅ **Centralized Exception Handling** with consistent error responses  
✅ **Swagger/OpenAPI** documentation  
✅ **Unit Testing** infrastructure  

The architecture is maintainable, testable, and follows industry best practices.

---

**Document Version**: 1.0  
**Last Updated**: November 16, 2025  
**Author**: Sakura Development Team

