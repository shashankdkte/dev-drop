# Sakura - Frontend/Backend Synchronization Analysis

## Document Information
- **Version**: 1.0
- **Date**: November 16, 2025
- **Purpose**: Identify gaps between FE and BE, provide standardization recommendations
- **Frontend Path**: `C:\Development\Sakura\FE\application`
- **Backend Path**: `C:\Development\Sakura\BE_Main\Sakura_Backend`

---

## Table of Contents
1. [Executive Summary](#executive-summary)
2. [Current State Analysis](#current-state-analysis)
3. [Compatibility Matrix](#compatibility-matrix)
4. [Identified Gaps](#identified-gaps)
5. [Synchronization Requirements](#synchronization-requirements)
6. [Frontend Standardization Recommendations](#frontend-standardization-recommendations)
7. [Backend Enhancements Needed](#backend-enhancements-needed)
8. [Implementation Roadmap](#implementation-roadmap)

---

## 1. Executive Summary

### Overview
The Sakura system consists of:
- **Frontend**: Angular 17+ Single Page Application
- **Backend**: .NET 8 Web API with Clean Architecture

### Current Status
‚úÖ **Working**: Authentication, Basic Workspace CRUD, Security Model CRUD  
‚ö†Ô∏è **Partial**: Property naming inconsistencies, missing endpoints  
‚ùå **Missing**: WorkspaceApp endpoints, Request/Approval system, Access Management

### Key Findings
1. **Property Naming Mismatch**: Frontend uses camelCase, Backend returns PascalCase
2. **Missing Endpoints**: ~15 endpoints needed by Frontend are not implemented
3. **Model Inconsistencies**: Frontend models expect fields not returned by Backend
4. **Authentication Sync**: Working but needs standardization
5. **Concurrency Token**: Backend implements, Frontend doesn't use
6. **Response Format**: Backend wraps in `{ success, data }`, Frontend expects unwrapping

---

## 2. Current State Analysis

### 2.1 Authentication Flow

#### Current Implementation

| Aspect | Frontend | Backend | Status |
|--------|----------|---------|--------|
| Local Auth | ‚úÖ Email + Password | ‚úÖ JWT Generation | ‚úÖ Working |
| Azure AD | ‚úÖ MSAL Integration | ‚úÖ Token Validation | ‚úÖ Working |
| Token Storage | ‚úÖ localStorage | ‚úÖ HttpOnly Cookie | ‚úÖ Working |
| Token Refresh | ‚ö†Ô∏è Basic check | ‚úÖ Refresh endpoint | ‚ö†Ô∏è Needs sync |
| User Claims | ‚úÖ userId, email, role, workspaceId | ‚úÖ Matches | ‚úÖ Working |

**Issues:**
- Frontend token refresh logic is incomplete (line 210-218 in auth.service.ts)
- Frontend doesn't call `/api/auth/refresh` endpoint
- Frontend checks token expiry but only logs warning

**Recommendation:**
```typescript
// Frontend: Implement actual refresh call
refreshTokenIfNeeded(): Observable<boolean> {
  if (this.isTokenExpired()) {
    return this.apiService.postRaw<RefreshTokenResponse>('/auth/refresh', {}).pipe(
      tap(response => {
        this.setToken(response.accessToken);
        return of(true);
      }),
      catchError(error => {
        this.logout();
        return of(false);
      })
    );
  }
  return of(true);
}
```

### 2.2 Workspace Management

#### Current Implementation

| Operation | Frontend Endpoint | Backend Endpoint | Status |
|-----------|-------------------|------------------|--------|
| List Workspaces | `/workspaces` | `GET /api/Workspace` | ‚úÖ Working |
| Get by ID | `/workspaces/:id` | `GET /api/Workspace/{id}` | ‚úÖ Working |
| Create | `/workspaces` | `POST /api/Workspace` | ‚ö†Ô∏è Property mismatch |
| Update | `/workspaces` | `PUT /api/Workspace` | ‚ö†Ô∏è Missing concurrency token |
| Delete | `/workspaces/delete` | `PUT /api/Workspace/delete` | ‚ö†Ô∏è Missing concurrency token |
| Search | `/workspaces/search` | ‚ùå Not implemented | ‚ùå Missing |
| Get Managed | `/workspaces/managed` | ‚ùå Not implemented | ‚ùå Missing |

**Property Mapping Issues:**

| Frontend (camelCase) | Backend (PascalCase) | Mapped in FE? |
|---------------------|---------------------|---------------|
| `workspaceId` | `Id` | ‚úÖ Yes (line 84) |
| `workspaceCode` | `WorkspaceCode` | ‚úÖ Yes |
| `workspaceName` | `WorkspaceName` | ‚úÖ Yes |
| `ownerUPN` | `WorkspaceOwner` | ‚úÖ Yes |
| `isActive` | `IsActive` | ‚úÖ Yes |

**Backend Response Example:**
```json
{
  "success": true,
  "data": [
    {
      "Id": 1,
      "WorkspaceName": "Americas",
      "WorkspaceCode": "AMER",
      "WorkspaceOwner": "owner@dentsu.com",
      "WorkspaceTechOwner": "tech@dentsu.com",
      "WorkspaceApprover": "approver@dentsu.com",
      "WorkspaceEntraGroupUID": null,
      "WorkspaceTag": null,
      "IsActive": true,
      "CreatedAt": "2025-11-15T10:00:00Z",
      "CreatedBy": "admin@dentsu.com",
      "UpdatedAt": "2025-11-15T10:00:00Z",
      "UpdatedBy": "admin@dentsu.com",
      "ConcurrencyToken": "abc123..."
    }
  ]
}
```

**Issues:**
1. Frontend expects `ownerUPN`, Backend returns `WorkspaceOwner`
2. Frontend doesn't send `ConcurrencyToken` on updates/deletes
3. Frontend hardcodes `createdBy` and `updatedBy` to `sakurahelp@dentsu.com` (should use current user)

### 2.3 WorkspaceApp Management

#### Current Status: ‚ùå NOT IMPLEMENTED IN BACKEND

**Frontend Expectations:**

| Operation | Frontend Endpoint | Backend Endpoint | Status |
|-----------|-------------------|------------------|--------|
| Get Apps by Workspace | `/workspaces/:workspaceId/apps` | ‚ùå Not implemented | ‚ùå Missing |
| Get App by ID | `/apps/:id` | ‚ùå Not implemented | ‚ùå Missing |
| Create App | `/apps` | ‚ùå Not implemented | ‚ùå Missing |
| Update App | `/apps/:id` | ‚ùå Not implemented | ‚ùå Missing |
| Delete App | `/apps/:id/delete` | ‚ùå Not implemented | ‚ùå Missing |
| Get All Apps | `/apps` | ‚ùå Not implemented | ‚ùå Missing |

**Frontend Model (workspace.model.ts):**
```typescript
export interface WorkspaceApp {
  appId: number;
  workspaceId: number;
  appCode: string;
  appName: string;
  approvalMode: 'AppBased' | 'AudienceBased';
  isActive: boolean;
}
```

**Backend Entity (WorkspaceApp.cs):**
```csharp
public class WorkspaceApp : SakuraAuditableEntity, ISoftDeletable
{
    public required string AppCode { get; set; }
    public required string AppName { get; set; }
    public required string AppOwner { get; set; }
    public required string AppTechnicalOwner { get; set; }
    public string AppEntraGroupUID { get; set; } = string.Empty;
    public OLSMode OLSMode { get; set; }
    public ApprovalMode ApprovalMode { get; set; }
    public string Approvers { get; set; } = string.Empty;
    public string AdditionalQuestionsJSON { get; set; } = string.Empty;
    public bool IsActive { get; set; }
    public int WorkspaceId { get; set; }
    public required Workspace Workspace { get; set; }
}
```

**Gap:** Backend has the entity but no controller/service/endpoints exposed.

### 2.4 Security Model Management

#### Current Implementation

| Operation | Frontend Endpoint | Backend Endpoint | Status |
|-----------|-------------------|------------------|--------|
| List Models | `/security-models` | `GET /api/Security` | ‚úÖ Working |
| Get by ID | `/security-models/:id` | `GET /api/Security/{id}` | ‚úÖ Working |
| Get by Code | `/security-models/code/:code` | `GET /api/Security/code/{code}` | ‚úÖ Working |
| Create | `/security-models` | `POST /api/Security` | ‚úÖ Working |
| Update | `/security-models/:id` | `PUT /api/Security/{id}` | ‚úÖ Working |
| Get Security Types | `/security-models/workspaces/:workspaceId/security-types` | `GET /api/Security/workspaces/{workspaceId}/security-types` | ‚úÖ Working |

**Frontend Model (security.model.ts):**
```typescript
export interface SecurityModel {
  securityModelId: number;
  workspaceId: number;
  securityModelCode: string;
  securityModelName: string;
  isActive: boolean;
}
```

**Backend Response (SecurityModelResponse.cs):**
```csharp
public class SecurityModelResponse : SakuraResponse
{
    public int Id { get; set; }
    public int WorkspaceId { get; set; }
    public string ModelCode { get; set; } = string.Empty;
    public string ModelName { get; set; } = string.Empty;
    public string? Description { get; set; }
    public List<string> SecurityTypes { get; set; } = new();
    public List<SecurityDimensionResponse> Dimensions { get; set; } = new();
    public bool IsActive { get; set; }
    // ... audit fields
}
```

**Property Mapping Issues:**

| Frontend | Backend | Mapped? |
|----------|---------|---------|
| `securityModelId` | `Id` | ‚ö†Ô∏è Needs mapping |
| `securityModelCode` | `ModelCode` | ‚ö†Ô∏è Needs mapping |
| `securityModelName` | `ModelName` | ‚ö†Ô∏è Needs mapping |

### 2.5 Request/Approval System

#### Current Status: ‚ùå NOT IMPLEMENTED IN BACKEND

**Frontend Expectations:**

| Operation | Frontend Endpoint | Backend Endpoint | Status |
|-----------|-------------------|------------------|--------|
| Submit Request | `/requests` | ‚ùå Not implemented | ‚ùå Missing |
| Get My Requests | `/requests/my-requests` | ‚ùå Not implemented | ‚ùå Missing |
| Get Request by ID | `/requests/:id` | ‚ùå Not implemented | ‚ùå Missing |
| Get My Approvals | `/approvals/my-approvals` | ‚ùå Not implemented | ‚ùå Missing |
| Approve Request | `/approvals/:requestId/approve` | ‚ùå Not implemented | ‚ùå Missing |
| Reject Request | `/approvals/:requestId/reject` | ‚ùå Not implemented | ‚ùå Missing |
| Revoke Access | `/approvals/:requestId/revoke` | ‚ùå Not implemented | ‚ùå Missing |

**Frontend Model (request.model.ts):**
```typescript
export interface AccessRequest {
  requestId: number;
  requestType: 'AppAccess' | 'AudienceAccess' | 'ReportAccess' | 'DatasetAccess';
  requestedByUPN: string;
  requestedByName: string;
  workspaceId: number;
  workspaceName: string;
  catalogItemId: number;
  catalogItemName: string;
  securityScope?: DimensionSelection[];
  businessJustification: string;
  status: 'Pending' | 'Approved' | 'Rejected' | 'Revoked';
  requestedDate: Date;
  reviewedByUPN?: string;
  reviewedDate?: Date;
  reviewComments?: string;
}
```

**Backend:** No corresponding entity or controller exists.

### 2.6 Admin/LoV Management

#### Current Implementation

| Operation | Frontend Endpoint | Backend Endpoint | Status |
|-----------|-------------------|------------------|--------|
| Get LoV Types | `/admin/types` | `GET /api/Admin/types` | ‚úÖ Working |
| Get LoVs by Type | `/admin/grid/:lovType` | `GET /api/Admin/grid/{lovType}` | ‚úÖ Working |
| Create LoV | `/admin` | `POST /api/Admin` | ‚úÖ Working |
| Update LoV | `/admin` | `PUT /api/Admin` | ‚úÖ Working |
| Delete LoV | `/admin/:LoVId` | `DELETE /api/Admin/{LoVId}` | ‚úÖ Working |

**Status:** ‚úÖ Fully Synchronized

---

## 3. Compatibility Matrix

### 3.1 API Endpoint Coverage

| Module | Total Endpoints Needed | Implemented | Partial | Missing | Coverage % |
|--------|------------------------|-------------|---------|---------|------------|
| Authentication | 4 | 3 | 1 | 0 | 75% |
| Workspace | 7 | 4 | 1 | 2 | 57% |
| WorkspaceApp | 6 | 0 | 0 | 6 | 0% |
| Security Model | 6 | 6 | 0 | 0 | 100% |
| Requests | 3 | 0 | 0 | 3 | 0% |
| Approvals | 4 | 0 | 0 | 4 | 0% |
| Admin (LoV) | 5 | 5 | 0 | 0 | 100% |
| Access Management | 4 | 0 | 0 | 4 | 0% |
| Catalogue | 1 | 0 | 0 | 1 | 0% |
| **Total** | **40** | **18** | **2** | **20** | **45%** |

### 3.2 Data Model Compatibility

| Entity | Frontend Model | Backend Entity | Response DTO | Compatibility |
|--------|---------------|----------------|--------------|---------------|
| Workspace | ‚úÖ workspace.model.ts | ‚úÖ Workspace.cs | ‚úÖ WorkspaceResponse | ‚ö†Ô∏è 80% (property names) |
| WorkspaceApp | ‚úÖ workspace.model.ts | ‚úÖ WorkspaceApp.cs | ‚ùå Missing | ‚ö†Ô∏è 60% (no endpoints) |
| SecurityModel | ‚úÖ security.model.ts | ‚úÖ SecurityModel.cs | ‚úÖ SecurityModelResponse | ‚ö†Ô∏è 85% (property names) |
| SecurityDimension | ‚úÖ security.model.ts | ‚úÖ SecurityDimension.cs | ‚úÖ SecurityDimensionResponse | ‚ö†Ô∏è 90% (minor differences) |
| User | ‚úÖ user.model.ts | ‚úÖ User.cs | ‚ùå Missing | ‚ö†Ô∏è 50% (minimal BE impl) |
| AccessRequest | ‚úÖ request.model.ts | ‚ùå Not implemented | ‚ùå Not implemented | ‚ùå 0% |
| LoVs | ‚úÖ Hardcoded types | ‚úÖ LoVs.cs | ‚úÖ ManageLoVDto | ‚úÖ 100% |

---

## 4. Identified Gaps

### 4.1 Critical Gaps (Blocks Core Functionality)

#### GAP-001: WorkspaceApp Management Missing
**Priority**: üî¥ Critical  
**Impact**: Frontend WSO Console cannot manage applications

**Required Endpoints:**
```
POST   /api/WorkspaceApp                      - Create app
GET    /api/WorkspaceApp/{id}                 - Get app by ID
GET    /api/Workspace/{workspaceId}/Apps      - Get apps by workspace
PUT    /api/WorkspaceApp                      - Update app
PUT    /api/WorkspaceApp/delete               - Soft delete app
```

**Required DTOs:**
- `CreateWorkspaceAppRequest` (with approvers list, OLSMode, ApprovalMode)
- `UpdateWorkspaceAppRequest` (with concurrency token)
- `DeleteWorkspaceAppRequest`
- `WorkspaceAppResponse` (with audit fields, concurrency token)

**Required Service:**
- `IWorkspaceAppService`
- `WorkspaceAppService` with CRUD + validation + concurrency checks

#### GAP-002: Request/Approval System Missing
**Priority**: üî¥ Critical  
**Impact**: Core workflow (request access ‚Üí approve/reject) doesn't work

**Required Entities:**
- `AccessRequest` with properties:
  - RequestId, RequestType, RequestedByUPN, WorkspaceId, CatalogItemId
  - SecurityScope (JSON), BusinessJustification, Status
  - Audit fields (RequestedDate, ReviewedByUPN, ReviewedDate)

**Required Endpoints:**
```
POST   /api/Request                           - Submit request
GET    /api/Request/{id}                      - Get request details
GET    /api/Request/my-requests               - Get my submitted requests
GET    /api/Approval/my-approvals             - Get pending approvals for current user
PUT    /api/Approval/{requestId}/approve      - Approve request
PUT    /api/Approval/{requestId}/reject       - Reject request
PUT    /api/Approval/{requestId}/revoke       - Revoke approved access
```

#### GAP-003: Audience Management Missing
**Priority**: üî¥ Critical  
**Impact**: Cannot manage audiences (room-level access control)

**Required Endpoints:**
```
POST   /api/Audience                          - Create audience
GET    /api/Audience/{id}                     - Get audience
GET    /api/App/{appId}/Audiences             - Get audiences by app
PUT    /api/Audience                          - Update audience
PUT    /api/Audience/delete                   - Soft delete audience
```

### 4.2 High Priority Gaps (Limits Functionality)

#### GAP-004: Workspace Search Not Implemented
**Priority**: üü† High  
**Impact**: Users cannot search workspaces in admin console

**Required:**
```
GET    /api/Workspace/search?query={text}     - Search workspaces by name/code/owner
```

#### GAP-005: User Management Missing
**Priority**: üü† High  
**Impact**: Cannot search for users when assigning owners/approvers

**Required:**
```
GET    /api/User/me                           - Get current user profile
GET    /api/User/search?query={text}          - Search users by email/name
```

#### GAP-006: Concurrency Token Not Used by Frontend
**Priority**: üü† High  
**Impact**: Lost updates possible, optimistic locking not enforced client-side

**Frontend Changes Needed:**
1. Store `ConcurrencyToken` from GET responses
2. Send `ConcurrencyToken` in PUT/DELETE requests
3. Handle 400 concurrency conflict errors gracefully

### 4.3 Medium Priority Gaps (Nice to Have)

#### GAP-007: Get Managed Workspaces Not Implemented
**Priority**: üü° Medium  
**Impact**: WSO Console cannot filter to "my workspaces"

**Required:**
```
GET    /api/Workspace/managed                 - Get workspaces where current user is owner
```

#### GAP-008: Catalogue Search Not Implemented
**Priority**: üü° Medium  
**Impact**: Request Form cannot search for reports/apps/audiences

**Required:**
```
GET    /api/Catalogue/search?query={text}&workspaceId={id}&type={Report|App|Audience}
```

#### GAP-009: Access Management Not Implemented
**Priority**: üü° Medium  
**Impact**: WSO cannot view/revoke granted access

**Required:**
```
GET    /api/Access/{catalogItemId}            - Get access records for item
DELETE /api/Access/{accessId}                 - Revoke access
```

---

## 5. Synchronization Requirements

### 5.1 Property Naming Standards

**Problem:** Backend returns PascalCase, Frontend expects camelCase.

**Solutions:**

#### Option A: Frontend Mapping (Current Approach)
Frontend maps properties in services (see `workspace.service.ts` lines 83-89).

**Pros:**
- Backend follows .NET conventions
- No backend changes needed

**Cons:**
- Repetitive mapping code
- Easy to miss properties
- Maintenance overhead

**Recommendation:** ‚úÖ Continue for now, add helper function

**Helper Function:**
```typescript
// src/app/utils/property-mapper.ts
export function mapPascalToCamel(obj: any): any {
  if (Array.isArray(obj)) {
    return obj.map(mapPascalToCamel);
  }
  
  if (obj !== null && typeof obj === 'object') {
    return Object.keys(obj).reduce((acc, key) => {
      const camelKey = key.charAt(0).toLowerCase() + key.slice(1);
      acc[camelKey] = mapPascalToCamel(obj[key]);
      return acc;
    }, {} as any);
  }
  
  return obj;
}
```

#### Option B: Backend camelCase Serialization
Configure ASP.NET Core to use camelCase JSON serialization.

**Implementation:**
```csharp
// Program.cs
services.AddControllers()
    .AddJsonOptions(options => {
        options.JsonSerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;
    });
```

**Pros:**
- Frontend receives data in expected format
- No mapping code needed

**Cons:**
- Deviates from .NET conventions
- May affect other consumers
- Hard to revert

**Recommendation:** ‚ö†Ô∏è Consider for Phase 2 after stabilizing API contracts

### 5.2 Response Format Standardization

**Current Backend Format:**
```json
{
  "success": true,
  "message": "Operation successful",
  "data": { ... }
}
```

**Frontend Expectations:**
- API Service expects `response.data` (wraps response in `ApiResponse<T>`)
- Some methods use `getRaw<T>()` to bypass wrapping
- Inconsistent unwrapping logic across services

**Recommendation:**

1. **Standardize Backend Responses:**
All endpoints should return:
```json
{
  "success": true,
  "data": <T>,
  "message": "Optional message",
  "errors": []
}
```

2. **Frontend API Service:**
Always unwrap `data` automatically:
```typescript
get<T>(endpoint: string, params?: any): Observable<T> {
  return this.http.get<ApiResponse<T>>(url, { params }).pipe(
    map(response => response.data as T), // Auto-unwrap
    catchError(this.handleError)
  );
}
```

3. **Update All Services:**
Remove manual unwrapping logic from workspace.service.ts, etc.

### 5.3 Audit Fields Standardization

**Backend Requirement:**
All write operations need `CreatedBy`, `UpdatedBy`, `DeletedBy`.

**Current Frontend:**
Hardcoded to `sakurahelp@dentsu.com` (workspace.service.ts lines 387, 445, 506).

**Recommendation:**

1. **Frontend: Use Current User:**
```typescript
// workspace.service.ts
createWorkspace(workspace: CreateWorkspaceRequest): Observable<Workspace> {
  const currentUser = this.authService.currentUserValue;
  
  const payload = {
    ...workspace,
    createdBy: currentUser?.email || 'unknown@dentsu.com'
  };
  
  return this.apiService.post<Workspace>('/workspaces', payload);
}
```

2. **Backend: Extract from JWT (Alternative):**
```csharp
// WorkspaceController.cs
[HttpPost]
public async Task<ActionResult> AddWorkspace([FromBody] CreateWorkspaceRequest request)
{
    var userEmail = User.FindFirst(ClaimTypes.Email)?.Value ?? "system@dentsu.com";
    request.CreatedBy = userEmail; // Override client-provided value
    
    var result = await _workspaceService.AddWorkspaceAsync(request);
    return Ok(result);
}
```

**Recommendation:** ‚úÖ Use server-side extraction (more secure)

### 5.4 Concurrency Token Integration

**Backend:** Implements optimistic concurrency with HMAC-SHA256 tokens.

**Frontend:** Doesn't use tokens (ignores `ConcurrencyToken` in responses).

**Integration Steps:**

1. **Frontend: Store Token**
```typescript
// workspace.service.ts
private workspaceTokens: Map<number, string> = new Map();

getWorkspaceById(id: number): Observable<Workspace> {
  return this.apiService.get<WorkspaceResponse>(`/workspaces/${id}`).pipe(
    map(response => {
      // Store token
      this.workspaceTokens.set(response.id, response.concurrencyToken);
      
      // Map to frontend model
      return this.mapToWorkspace(response);
    })
  );
}
```

2. **Frontend: Send Token on Update**
```typescript
updateWorkspace(id: number, workspace: Workspace): Observable<Workspace> {
  const token = this.workspaceTokens.get(id);
  
  const payload = {
    ...workspace,
    id: id,
    updatedBy: this.authService.currentUserValue?.email,
    concurrencyToken: token // Include token
  };
  
  return this.apiService.put<WorkspaceResponse>('/workspaces', payload).pipe(
    map(response => {
      // Update stored token with new value
      this.workspaceTokens.set(response.id, response.concurrencyToken);
      return this.mapToWorkspace(response);
    }),
    catchError(error => {
      if (error.statusCode === 400 && error.message.includes('concurrent')) {
        // Show user-friendly message
        return throwError(() => ({
          ...error,
          message: 'This record was modified by another user. Please refresh and try again.'
        }));
      }
      return throwError(() => error);
    })
  );
}
```

3. **Frontend: Handle Conflicts**
```typescript
// In component
updateWorkspace(workspace: Workspace) {
  this.workspaceService.updateWorkspace(workspace.id, workspace).subscribe({
    next: (updated) => {
      this.toastService.success('Workspace updated successfully');
      this.workspace = updated;
    },
    error: (error) => {
      if (error.message.includes('concurrent')) {
        this.toastService.error(error.message);
        this.refreshWorkspace(); // Reload from server
      } else {
        this.toastService.error('Update failed');
      }
    }
  });
}
```

---

## 6. Frontend Standardization Recommendations

### 6.1 Model Naming Convention

**Current:** Mixed conventions across models

**Recommendation:** Adopt consistent naming

| Convention | Example | Usage |
|------------|---------|-------|
| PascalCase | `WorkspaceModel` | Class/interface names |
| camelCase | `workspaceId`, `workspaceName` | Property names |
| kebab-case | `workspace-service.ts` | File names |
| UPPER_SNAKE_CASE | `MAX_PAGE_SIZE` | Constants |

**Standardize Interface Names:**
```typescript
// ‚ùå Inconsistent
export interface Workspace { }
export interface WorkspaceApp { }
export interface SecurityModel { }

// ‚úÖ Consistent
export interface Workspace { }
export interface WorkspaceApp { }
export interface SecurityModel { }
export interface SecurityDimension { }
export interface AccessRequest { }
```

### 6.2 Service Organization

**Current Structure:**
```
services/
  - api.service.ts (base HTTP)
  - auth.service.ts
  - workspace.service.ts
  - wso.service.ts (mixed WSO operations)
  - request.service.ts
  - approval.service.ts
  - etc.
```

**Recommendation:** Group by domain

```
services/
  - core/
    - api.service.ts
    - auth.service.ts
  - workspace/
    - workspace.service.ts
    - workspace-app.service.ts
    - workspace-audience.service.ts
  - security/
    - security-model.service.ts
    - security-dimension.service.ts
  - request/
    - access-request.service.ts
    - approval.service.ts
  - admin/
    - lov.service.ts
    - user.service.ts
  - shared/
    - notification.service.ts
    - toast.service.ts
```

### 6.3 Error Handling

**Current:** Inconsistent error handling across services

**Recommendation:** Centralize error handling

```typescript
// services/core/error-handler.service.ts
@Injectable({ providedIn: 'root' })
export class ErrorHandlerService {
  handle(error: any, context?: string): Observable<never> {
    let userMessage = 'An error occurred';
    
    if (error.statusCode === 400 && error.message.includes('concurrent')) {
      userMessage = 'This record was modified. Please refresh.';
    } else if (error.statusCode === 401) {
      userMessage = 'Please log in again.';
      this.authService.logout();
    } else if (error.statusCode === 403) {
      userMessage = 'You do not have permission.';
    } else if (error.statusCode === 404) {
      userMessage = 'Resource not found.';
    } else if (error.message) {
      userMessage = error.message;
    }
    
    this.toastService.error(userMessage, context);
    return throwError(() => error);
  }
}

// Usage in services
this.apiService.post(...).pipe(
  catchError(error => this.errorHandler.handle(error, 'Create Workspace'))
);
```

### 6.4 Loading State Management

**Current:** Each component manages loading state independently

**Recommendation:** Centralized loading overlay

```typescript
// services/loading.service.ts
@Injectable({ providedIn: 'root' })
export class LoadingService {
  private loadingSubject = new BehaviorSubject<boolean>(false);
  public isLoading$ = this.loadingSubject.asObservable();
  private activeRequests = 0;
  
  show() {
    this.activeRequests++;
    this.loadingSubject.next(true);
  }
  
  hide() {
    this.activeRequests = Math.max(0, this.activeRequests - 1);
    if (this.activeRequests === 0) {
      this.loadingSubject.next(false);
    }
  }
}

// Interceptor
@Injectable()
export class LoadingInterceptor implements HttpInterceptor {
  constructor(private loading: LoadingService) {}
  
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    this.loading.show();
    
    return next.handle(req).pipe(
      finalize(() => this.loading.hide())
    );
  }
}
```

### 6.5 TypeScript Strict Mode

**Current:** `strict: false` in tsconfig.json

**Recommendation:** Enable strict mode incrementally

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "alwaysStrict": true
  }
}
```

**Migration Steps:**
1. Enable `noImplicitAny` first
2. Fix errors file by file
3. Enable `strictNullChecks`
4. Fix null/undefined errors
5. Enable remaining flags

---

## 7. Backend Enhancements Needed

### 7.1 Missing Controllers

#### Priority 1: WorkspaceAppController
```csharp
[ApiController]
[Route("api/[controller]")]
public class WorkspaceAppController : ControllerBase
{
    private readonly IWorkspaceAppService _service;
    
    [HttpGet("{id}")]
    public async Task<ActionResult<ApiSingleResult<WorkspaceAppResponse>>> GetWorkspaceApp(int id) { }
    
    [HttpGet]
    [Route("/api/Workspace/{workspaceId}/Apps")]
    public async Task<ActionResult<ApiListResult<WorkspaceAppResponse>>> GetAppsByWorkspace(int workspaceId) { }
    
    [HttpPost]
    public async Task<ActionResult<ApiSingleResult<WorkspaceAppResponse>>> CreateApp(CreateWorkspaceAppRequest request) { }
    
    [HttpPut]
    public async Task<ActionResult<ApiSingleResult<WorkspaceAppResponse>>> UpdateApp(UpdateWorkspaceAppRequest request) { }
    
    [HttpPut("delete")]
    public async Task<ActionResult<ApiScalarResult<bool>>> DeleteApp(DeleteWorkspaceAppRequest request) { }
}
```

#### Priority 2: RequestController + ApprovalController
```csharp
[ApiController]
[Route("api/[controller]")]
public class RequestController : ControllerBase
{
    [HttpPost]
    public async Task<ActionResult<ApiSingleResult<AccessRequestResponse>>> SubmitRequest(CreateAccessRequestRequest request) { }
    
    [HttpGet("{id}")]
    public async Task<ActionResult<ApiSingleResult<AccessRequestResponse>>> GetRequest(int id) { }
    
    [HttpGet("my-requests")]
    public async Task<ActionResult<ApiListResult<AccessRequestResponse>>> GetMyRequests() { }
}

[ApiController]
[Route("api/[controller]")]
public class ApprovalController : ControllerBase
{
    [HttpGet("my-approvals")]
    public async Task<ActionResult<ApiListResult<AccessRequestResponse>>> GetMyApprovals() { }
    
    [HttpPut("{requestId}/approve")]
    public async Task<ActionResult<ApiSingleResult<AccessRequestResponse>>> ApproveRequest(int requestId, ApproveRequestRequest request) { }
    
    [HttpPut("{requestId}/reject")]
    public async Task<ActionResult<ApiSingleResult<AccessRequestResponse>>> RejectRequest(int requestId, RejectRequestRequest request) { }
    
    [HttpPut("{requestId}/revoke")]
    public async Task<ActionResult<ApiScalarResult<bool>>> RevokeAccess(int requestId, RevokeAccessRequest request) { }
}
```

#### Priority 3: AudienceController
```csharp
[ApiController]
[Route("api/[controller]")]
public class AudienceController : ControllerBase
{
    [HttpGet("{id}")]
    public async Task<ActionResult<ApiSingleResult<AudienceResponse>>> GetAudience(int id) { }
    
    [HttpGet]
    [Route("/api/App/{appId}/Audiences")]
    public async Task<ActionResult<ApiListResult<AudienceResponse>>> GetAudiencesByApp(int appId) { }
    
    [HttpPost]
    public async Task<ActionResult<ApiSingleResult<AudienceResponse>>> CreateAudience(CreateAudienceRequest request) { }
    
    [HttpPut]
    public async Task<ActionResult<ApiSingleResult<AudienceResponse>>> UpdateAudience(UpdateAudienceRequest request) { }
    
    [HttpPut("delete")]
    public async Task<ActionResult<ApiScalarResult<bool>>> DeleteAudience(DeleteAudienceRequest request) { }
}
```

### 7.2 Missing Domain Entities

#### AccessRequest Entity
```csharp
namespace Dentsu.Sakura.Domain.Entities.Requests
{
    public class AccessRequest : SakuraAuditableEntity, ISoftDeletable
    {
        public required string RequestType { get; set; } // AppAccess, AudienceAccess, ReportAccess
        public required string RequestedByUPN { get; set; }
        public int WorkspaceId { get; set; }
        public int CatalogItemId { get; set; } // ID of App/Audience/Report
        public string? SecurityScopeJSON { get; set; } // Dimension selections for RLS
        public required string BusinessJustification { get; set; }
        public required string Status { get; set; } // Pending, Approved, Rejected, Revoked
        public DateTime RequestedDate { get; set; }
        public string? ReviewedByUPN { get; set; }
        public DateTime? ReviewedDate { get; set; }
        public string? ReviewComments { get; set; }
        public bool IsActive { get; set; }
        
        // Navigation properties
        public Workspace? Workspace { get; set; }
    }
}
```

#### Audience Entity
```csharp
namespace Dentsu.Sakura.Domain.Entities.Workspaces
{
    public class Audience : SakuraAuditableEntity, ISoftDeletable
    {
        public required string AudienceCode { get; set; }
        public required string AudienceName { get; set; }
        public int AppId { get; set; }
        public required string OwnerUPN { get; set; }
        public string? SupportContactUPN { get; set; }
        public string? Description { get; set; }
        public string? OLSApproverUPN { get; set; }
        public int SecurityModelId { get; set; }
        public string? DimensionValuesJSON { get; set; } // JSON array of dimension selections
        public string? LinkedReportIds { get; set; } // Comma-separated IDs
        public bool IsActive { get; set; }
        
        // Navigation properties
        public WorkspaceApp? App { get; set; }
        public SecurityModel? SecurityModel { get; set; }
    }
}
```

### 7.3 Additional Workspace Endpoints

```csharp
// WorkspaceController.cs additions
[HttpGet("search")]
public async Task<ActionResult<ApiListResult<WorkspaceResponse>>> SearchWorkspaces([FromQuery] string query)
{
    var results = await _workspaceService.SearchWorkspacesAsync(query);
    return Ok(new ApiListResult<WorkspaceResponse> { Success = true, Data = results });
}

[HttpGet("managed")]
public async Task<ActionResult<ApiListResult<WorkspaceResponse>>> GetManagedWorkspaces()
{
    var currentUserEmail = User.FindFirst(ClaimTypes.Email)?.Value;
    if (string.IsNullOrEmpty(currentUserEmail))
        return Unauthorized();
    
    var results = await _workspaceService.GetManagedWorkspacesAsync(currentUserEmail);
    return Ok(new ApiListResult<WorkspaceResponse> { Success = true, Data = results });
}
```

### 7.4 User Search Endpoint

```csharp
[ApiController]
[Route("api/[controller]")]
public class UserController : ControllerBase
{
    private readonly IUserService _userService;
    
    [HttpGet("me")]
    public async Task<ActionResult<ApiSingleResult<UserResponse>>> GetCurrentUser()
    {
        var userEmail = User.FindFirst(ClaimTypes.Email)?.Value;
        if (string.IsNullOrEmpty(userEmail))
            return Unauthorized();
        
        var user = await _userService.GetUserByEmailAsync(userEmail);
        return Ok(new ApiSingleResult<UserResponse> { Success = true, Data = user });
    }
    
    [HttpGet("search")]
    public async Task<ActionResult<ApiListResult<UserResponse>>> SearchUsers([FromQuery] string query)
    {
        // Search Azure AD or local user table
        var results = await _userService.SearchUsersAsync(query);
        return Ok(new ApiListResult<UserResponse> { Success = true, Data = results });
    }
}
```

### 7.5 Response Format Standardization

**Current:** Controllers return inconsistent formats

**Recommendation:** Use global result filter

```csharp
// Filters/StandardResponseFilter.cs
public class StandardResponseFilter : IActionFilter
{
    public void OnActionExecuting(ActionExecutingContext context) { }
    
    public void OnActionExecuted(ActionExecutedContext context)
    {
        if (context.Result is ObjectResult objectResult)
        {
            var value = objectResult.Value;
            
            // If already wrapped, leave it
            if (value is IApiBaseResult)
                return;
            
            // Wrap in standard response
            objectResult.Value = new
            {
                success = true,
                data = value
            };
        }
    }
}

// Program.cs
builder.Services.AddControllers(options =>
{
    options.Filters.Add<StandardResponseFilter>();
});
```

---

## 8. Implementation Roadmap

### Phase 1: Critical Gaps (2-3 weeks)

#### Week 1: WorkspaceApp Management
- [ ] Create `WorkspaceApp` domain layer
  - [ ] Entity (already exists)
  - [ ] Repository interface
  - [ ] Service interface
- [ ] Create `WorkspaceApp` application layer
  - [ ] DTOs (Create/Update/Delete requests)
  - [ ] Response models
  - [ ] Validators (FluentValidation)
  - [ ] Service implementation
  - [ ] Mapster configuration
- [ ] Create `WorkspaceApp` API layer
  - [ ] WorkspaceAppController
  - [ ] Route: `/api/WorkspaceApp`
  - [ ] Endpoints: GET, GET by ID, POST, PUT, DELETE
- [ ] Frontend integration
  - [ ] Create `workspace-app.service.ts`
  - [ ] Update endpoint mappings
  - [ ] Test CRUD operations
- [ ] Testing
  - [ ] Unit tests for service
  - [ ] Integration tests for controller

#### Week 2: Request/Approval System (Part 1 - Domain & API)
- [ ] Create `AccessRequest` domain layer
  - [ ] Entity
  - [ ] Repository interface
  - [ ] Service interface
- [ ] Create `AccessRequest` application layer
  - [ ] DTOs (Submit, Approve, Reject, Revoke)
  - [ ] Response models
  - [ ] Validators
  - [ ] Service implementation (request submission logic)
- [ ] Create `Request` API layer
  - [ ] RequestController
  - [ ] Endpoints: POST (submit), GET (by ID), GET (my requests)

#### Week 3: Request/Approval System (Part 2 - Approval Flow)
- [ ] Create `Approval` application layer
  - [ ] Service implementation (approval logic)
  - [ ] Notification logic (email/system notifications)
- [ ] Create `Approval` API layer
  - [ ] ApprovalController
  - [ ] Endpoints: GET (my approvals), PUT (approve/reject/revoke)
- [ ] Frontend integration
  - [ ] Update request.service.ts
  - [ ] Update approval.service.ts
  - [ ] Test end-to-end flow
- [ ] Testing
  - [ ] Unit tests
  - [ ] Integration tests
  - [ ] Manual E2E testing

### Phase 2: High Priority Enhancements (2 weeks)

#### Week 4: Audience Management
- [ ] Create `Audience` domain layer
  - [ ] Entity
  - [ ] Repository
  - [ ] Service interface
- [ ] Create `Audience` application layer
  - [ ] DTOs and responses
  - [ ] Validators
  - [ ] Service implementation
- [ ] Create `Audience` API layer
  - [ ] AudienceController
  - [ ] Endpoints: CRUD operations
- [ ] Frontend integration
  - [ ] Create audience.service.ts
  - [ ] Update WSO Console

#### Week 5: User Management & Search
- [ ] Create `User` management
  - [ ] UserController
  - [ ] UserService
  - [ ] `/api/User/me` endpoint
  - [ ] `/api/User/search` endpoint
- [ ] Add workspace search
  - [ ] `WorkspaceService.SearchWorkspacesAsync()`
  - [ ] `WorkspaceController.SearchWorkspaces()`
- [ ] Add managed workspaces filter
  - [ ] `WorkspaceService.GetManagedWorkspacesAsync()`
  - [ ] `WorkspaceController.GetManagedWorkspaces()`
- [ ] Frontend integration
  - [ ] Update workspace.service.ts
  - [ ] Create user.service.ts
  - [ ] Update user pickers/dropdowns

### Phase 3: Standardization & Polish (1-2 weeks)

#### Week 6: Frontend Standardization
- [ ] Implement property mapper utility
- [ ] Centralize error handling
- [ ] Add concurrency token integration
- [ ] Standardize service organization
- [ ] Update all components to use standardized services

#### Week 7: Backend Standardization
- [ ] Add standard response filter
- [ ] Implement audit field extraction from JWT
- [ ] Add comprehensive logging
- [ ] Update all controllers to use standard patterns
- [ ] Performance optimization (caching, query optimization)

### Phase 4: Testing & Documentation (1 week)

#### Week 8: Final Testing
- [ ] E2E testing (all flows)
- [ ] Load testing
- [ ] Security testing
- [ ] Bug fixes
- [ ] Update API documentation (Swagger)
- [ ] Update developer documentation

---

## Summary of Changes Needed

### Backend (BE_Main) Changes

#### Must Implement (Critical)
1. **WorkspaceAppController + Service** - 6 endpoints
2. **RequestController + Service** - 3 endpoints
3. **ApprovalController + Service** - 4 endpoints
4. **AudienceController + Service** - 5 endpoints
5. **AccessRequest Entity** - New domain entity
6. **Audience Entity** - New domain entity

#### Should Implement (High Priority)
7. **Workspace Search** - 1 endpoint
8. **Managed Workspaces** - 1 endpoint
9. **User Management** - 2 endpoints
10. **Standard Response Filter** - Global formatting

#### Nice to Have (Medium Priority)
11. **Catalogue Search** - 1 endpoint
12. **Access Management** - 2 endpoints
13. **camelCase JSON Serialization** - Configuration change

### Frontend (FE) Changes

#### Must Fix (Critical)
1. **Concurrency Token Integration** - Store and send tokens
2. **Audit Field Population** - Use current user, not hardcoded
3. **Error Handling** - Handle concurrency conflicts gracefully

#### Should Fix (High Priority)
4. **Token Refresh Implementation** - Call `/auth/refresh`
5. **Property Mapping Utility** - Centralize PascalCase ‚Üí camelCase
6. **Service Organization** - Group by domain

#### Nice to Have (Medium Priority)
7. **TypeScript Strict Mode** - Enable incrementally
8. **Centralized Loading** - Use interceptor
9. **Error Handler Service** - Centralize error handling

---

## Conclusion

The Sakura frontend and backend are **45% synchronized** in terms of API coverage. Critical gaps exist in **WorkspaceApp management**, **Request/Approval system**, and **Audience management**, which block core workflows.

**Immediate Actions:**
1. Implement WorkspaceAppController (Week 1)
2. Implement Request/Approval system (Weeks 2-3)
3. Integrate concurrency tokens in Frontend (Week 6)

**Timeline:** 8 weeks for full synchronization + standardization

**Effort Estimate:**
- Backend: ~120 hours
- Frontend: ~40 hours
- Testing: ~40 hours
- **Total: ~200 hours (5 person-weeks)**

---

**Document Version**: 1.0  
**Last Updated**: November 16, 2025  
**Next Review**: After Phase 1 completion

